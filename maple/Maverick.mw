<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2016" minor="1"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" preplot="" helpbrowser="standard" contextmenusize="automatic" displayprecision="-1" echo="1" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="1088" rtablesize="10" useclientjvm="true" labelwidth="20" postplot="" typesetting="standard" ansi="false" elisiondigitsthreshold="10000" showassumed="1" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="true"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[42,114,163]" italic="false" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Variable" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Left Justified Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[42,114,163]" italic="true" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[42,114,163]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output6" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[42,114,163]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,128]" italic="false" opaque="false" readonly="true" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Underlined Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="sub-Title" background="[255,255,255]" bold="false" executable="false" family="Baskerville" foreground="[15,115,169]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Copyright" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output12" background="[255,255,255]" bold="false" executable="false" family="Verdana" foreground="[51,51,153]" italic="false" opaque="false" readonly="false" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Comment" background="[255,255,255]" bold="true" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Popup" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Serif" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Plot Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="8" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="aa" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Geneva" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="true" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,102,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Small" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[128,128,128]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Bold Small" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Menus" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Heading" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[47,66,152]" italic="false" opaque="false" readonly="true" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Fixed Width" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[51,155,255]" italic="false" opaque="false" readonly="true" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="false" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Page Number" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="R3 Font 0" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="false" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="false" executable="false" family="Baskerville" foreground="[41,111,169]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="9" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Italic Small204" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Fixed" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Output Labels" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="8" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Help Notes" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Underlined" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math Italic Small" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="1" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Symbol 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Nonterminal" background="[255,255,255]" bold="true" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Georgia" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Maple Name" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[104,64,92]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal257" background="[255,255,255]" bold="true" executable="false" family="Arial" foreground="[0,0,255]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[255,0,0]" italic="false" opaque="false" readonly="true" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[42,114,163]" italic="false" opaque="false" readonly="false" size="24" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Monospaced" foreground="[0,128,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Plot Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Underlined Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="11" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Italic Bold" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Default" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Section" background="[255,255,255]" bold="true" executable="false" family="Baskerville" foreground="[6,137,223]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Monospaced" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="LaTeX" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Emphasized" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Help Italic" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Comment" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Prompt" background="[255,255,255]" bold="true" executable="false" family="Monospaced" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math Bold" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Arial" foreground="[18,93,153]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Helvetica Neue" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="6" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Fixed Width" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Left Justified Maple Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Help" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="10" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Text Output6" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="10" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="R3 Font 0" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Annotation Title" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="6" spacebelow="6" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="sub-Title" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output12" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal257" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.2" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Section" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="6" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="6" spacebelow="6" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group hide-input="false" hide-output="false" labelreference="L1" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart;</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">mylib :=cat(currentdir(),&quot;/Maverick/lib/Maverick.mla&quot;);</Text-field>
</Input>
<Output><Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYoLUkjbWlHRiQ2JVEmbXlsaWJGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSp+JiM4Nzg4O35GJy9GM1Enbm9ybWFsRicvJSZmZW5jZUdRJmZhbHNlRicvJSpzZXBhcmF0b3JHRj0vJSlzdHJldGNoeUdGPS8lKnN5bW1ldHJpY0dGPS8lKGxhcmdlb3BHRj0vJS5tb3ZhYmxlbGltaXRzR0Y9LyUnYWNjZW50R0Y9LyUnbHNwYWNlR1EmMC4wZW1GJy8lJ3JzcGFjZUdGTC1JI21zR0YkNiNRZ24vbWVkaWEvc2ZfU2hhcmVkX3ZtL01hdmVyaWNrL21hcGxlL01hdmVyaWNrL2xpYi9NYXZlcmljay5tbGFGJy8lK2ZvcmVncm91bmRHUShbMCwwLDBdRicvJSlyZWFkb25seUdGPUY5">UWduL21lZGlhL3NmX1NoYXJlZF92bS9NYXZlcmljay9tYXBsZS9NYXZlcmljay9saWIvTWF2ZXJpY2subWxhNiI=</Equation></Text-field>
</Output>
</Group>
<Group hide-output="false" labelreference="L543" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field style="Normal" layout="Normal"><Font style="Text">remove any outdated file</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">FileTools[Remove](mylib);</Text-field>
</Input>
<Input><Text-field style="Normal" layout="Normal"><Font style="Text">create the repository</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">march( 'create', mylib, 100 );  <Font style="Text">create a private repositoty (only the first time)</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">libname := libname, mylib:
savelibname := mylib:</Text-field>
</Input>
</Group>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Code generation subroutines</Text-field></Title>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Maverick utility procedures</Text-field></Title>
<Group hide-output="false" labelreference="L546" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickUtils := module()</Text-field><Text-field style="Normal" layout="Normal"> <Font style="Maple Input">    description &quot;asd&quot;;
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">Module options</Font>
option package,
       load = init;   <Font style="Text">all exported names are automatically protected
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global  __output_array_cc, __output_guess_array_cc, __output_array_hh, __output_guess_array_hh,
          __original_array_cc, __original_guess_array_cc, __original_array_hh, __original_guess_array_hh,
          __output_array_main_cc,
          __num_phases, __tabs, __debug:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local     _getGradient,
          _getGradientNamed,
          _getJacobianAndStructure,
          _getHessianAndStructure,
          _findIndexOfInArray,
          _replaceInArray,
          _replaceAllInArray,
          _replaceInTemplateCC,
          _replaceInTemplateHH,
          _replaceInGuessTemplateHH,
          _replaceInGuessTemplateCC,

          _replaceAllInTemplateCC,
          _replaceAllInTemplateHH,
          _replaceAllInGuessTemplateCC,
          _replaceAllInGuessTemplateHH,
          _diF,
          _getCodeForPhases,
          _xoapifj,
          noLicenseMessage:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export getGradient,
          getGradientNamed,
          getJacobianAndStructure,
          getHessianAndStructure,
          findIndexOfInArray,
          replaceInArray,
          replaceAllInArray,
          replaceInTemplateCC,
          replaceInTemplateHH,
          replaceInGuessTemplateHH,
          replaceInGuessTemplateCC,

          replaceAllInTemplateCC,
          replaceAllInTemplateHH,
          replaceAllInGuessTemplateCC,
          replaceAllInGuessTemplateHH,
          diF,
          getCodeForPhases:


</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">noLicenseMessage := proc()
    error(&quot;You do not hold a valid Maverick license&quot;):
end:
</Text-field>
</Input>
<Input><Text-field style="Text" layout="Normal">Return an array which is the gradient of the expression with respect to X</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getGradient := proc(expr::list, X::list) _getGradient(expr, X): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_getGradient := proc(expr::list, X::list)
local i, gradient, j;

   gradient := Array(1..nops(expr),1..nops(X)):  
   for i from 1 to nops(expr) do
      for j from 1 to nops(X) do
          gradient[i,j] := diF(expr[i], X[j]):
      end do:
   end do:
   gradient:

end proc;
</Text-field>
</Input>
<Input><Text-field style="Text" layout="Normal">Return an array in the form gradient_name[i] = gradient of expr w.r.t. X[i]</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getGradientNamed := proc(expr::list, X::list, gradient_name::symbol) _getGradientNamed(expr, X, gradient_name::symbol): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_getGradientNamed := proc(expr, X, gradient_name::symbol)
local i, gradient;

   gradient := getGradient(expr, X):
   for i from 1 to ArrayTools[NumElems]<Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[0,0,0]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Halfline" placeholder="false" family="Monospaced" font_style_name="Halfline"> (gradient)</Font> do
      gradient[i] := gradient_name[i] = gradient[i]:
   end do:

   gradient;
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getJacobianAndStructure := proc(expr::list, X::list, name) _getJacobianAndStructure(expr, X, name): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_getJacobianAndStructure := proc(expr, X, name)
local jacobian, nnz, ix, iy, C_iCols, C_iRows, linearJacobianNamed, i;

   _xoapifj():

   jacobian := getGradient(expr, X):
   #jacobian := LinearAlgebra[Transpose](jacobian):

   <Font style="Text">now calculate the structure</Font>
   nnz := 0: C_iCols := []: C_iRows := []:
   for iy from 1 to ArrayTools[Size](jacobian,2) do
   for ix from 1 to ArrayTools[Size](jacobian,1) do
       if not( jacobian[ix,iy]=0) then
           nnz := nnz+1:
           C_iRows := [op(C_iRows), ix - 1]:
           C_iCols := [op(C_iCols), iy - 1]:
       end if:  
   end do:
   end do:

   C_iRows := convert(C_iRows, Array);
   C_iCols := convert(C_iCols, Array);
   linearJacobianNamed := []:
   for i from 1 to nnz do
       linearJacobianNamed := [op(linearJacobianNamed), name[i] = jacobian[C_iRows[i] + 1,C_iCols[i] + 1] ]:
       C_iRows[i] := rows[i] = C_iRows[i]:
       C_iCols[i] := cols[i] = C_iCols[i]:
   end do:

   jacobian, nnz, C_iRows, C_iCols, linearJacobianNamed:
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getHessianAndStructure := proc(expr::algebraic, difRows::list, difCols::list, name) _getHessianAndStructure(expr, difRows, difCols, name) end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_getHessianAndStructure := proc(expr, difRows, difCols, name)
local hessian, nnz, ix, iy, C_iCols, C_iRows, linearHessianNamed, i;

   _xoapifj():
   hessian := convert(getGradient([expr], difCols),list):
   hessian := getGradient(hessian, difRows):

   <Font style="Text">now calculate the structure</Font>
   nnz := 0: C_iCols := []: C_iRows := []:
   for iy from 1 to ArrayTools[Size](hessian,2) do
   for ix from 1 to ArrayTools[Size](hessian,1) do
       if not( hessian[ix,iy]=0) then
           nnz := nnz+1:
           C_iRows := [op(C_iRows), ix - 1]:
           C_iCols := [op(C_iCols), iy - 1]:
       end if:  
   end do:
   end do:
   C_iRows := convert(C_iRows, Array);
   C_iCols := convert(C_iCols, Array);
   linearHessianNamed := []:
   for i from 1 to nnz do
       linearHessianNamed := [op(linearHessianNamed), name[i] = hessian[C_iRows[i] + 1,C_iCols[i] + 1] ]:
       C_iRows[i] := rows[i] = C_iRows[i]:
       C_iCols[i] := cols[i] = C_iCols[i]:
   end do:

   hessian, nnz, C_iRows, C_iCols, linearHessianNamed:
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">findIndexOfInArray := proc(what::string, template::Array) _findIndexOfInArray(what, template): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_findIndexOfInArray := proc(what::string, template::Array)
local index, i:

   index := 0;
   for i from 1 to ArrayTools[NumElems](template) do
      if ( not(evalb(template[i]=&quot;&quot;)) and (StringTools[Search](what,template[i]) &gt; 0) )
          then index := i; break; end if;
   end do;
   if (index=0) then error(&quot;Index not found&quot;); end if:

   index;
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceInArray := proc(what::string, with::string, template::Array) _replaceInArray(what, with, template): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceInArray := proc(what::string, with::string, template::Array)
local i, index;

   index := findIndexOfInArray(what, template):
   template[index] := StringTools[Substitute](template[index],what,with):
   
   template, index;
end proc:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceAllInArray := proc(what::string, with::string, template::Array) _replaceAllInArray(what, with, template): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceAllInArray := proc(what::string, with::string, template::Array)
local i:

   for i from 1 to ArrayTools[NumElems](template) do
      if ( not(evalb(template[i]=&quot;&quot;)) and (StringTools[Search](what,template[i]) &gt; 0) )
          then 
          template[i] := StringTools[SubstituteAll](template[i],  what, with):
      end if;
   end do;

   template:
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceInTemplateCC := proc(what::string, with::string) _replaceInTemplateCC(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceInTemplateCC := proc(what::string, with::string)
local i, index;
global __output_array_cc;

   __output_array_cc, index := replaceInArray(what, with, __output_array_cc):

   __output_array_cc[index];
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceInTemplateHH := proc(what::string, with::string) _replaceInTemplateHH(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceInTemplateHH := proc(what::string, with::string)
local i, index;
global __output_array_hh;

   __output_array_hh, index := replaceInArray(what, with, __output_array_hh):

   __output_array_hh[index];
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceInGuessTemplateCC := proc(what::string, with::string) _replaceInGuessTemplateCC(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceInGuessTemplateCC := proc(what::string, with::string)
local i, index;
global __output_guess_array_cc;


   __output_guess_array_cc, index := replaceInArray(what, with, __output_guess_array_cc):

   __output_guess_array_cc[index];
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceAllInTemplateCC := proc(what::string, with::string) _replaceAllInTemplateCC(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceAllInTemplateCC := proc(what::string, with::string)
local i:
global __output_array_cc;

   __output_array_cc := replaceAllInArray(what, with, __output_array_cc):
end proc:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceAllInGuessTemplateCC := proc(what::string, with::string) _replaceAllInGuessTemplateCC(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceAllInGuessTemplateCC := proc(what::string, with::string)
local i:
global __output_guess_array_cc;

   __output_guess_array_cc := replaceAllInArray(what, with, __output_guess_array_cc):
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceAllInTemplateHH := proc(what::string, with::string) _replaceAllInTemplateHH(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceAllInTemplateHH := proc(what::string, with::string)
local i:
global __output_array_hh;

   __output_array_hh := replaceAllInArray(what, with, __output_array_hh):
end proc:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">replaceAllInGuessTemplateHH := proc(what::string, with::string) _replaceAllInGuessTemplateHH(what, with): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_replaceAllInGuessTemplateHH := proc(what::string, with::string)
local i:
global __output_guess_array_hh;

   __output_guess_array_hh := replaceAllInArray(what, with, __output_guess_array_hh):
end proc:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getCodeForPhases := proc(input, append_code::string:= &quot;&quot;) _getCodeForPhases(input,append_code): end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_getCodeForPhases := proc(input,append_code)
    local P, out_code;
    if (__num_phases&gt;1) then
     <Font encoding="UTF-8">    out_code := &quot;switch(i_phase) {\134n&quot;:
</Font>
        for P from 1 to __num_phases do
            if ((input[P]&lt;&gt;&quot;&quot;) and (<Font encoding="UTF-8">input[P]&lt;&gt;&quot;\134n&quot;) and (</Font>input[P]&lt;&gt;&quot; &quot;) )then
                out_code := cat(<Font encoding="UTF-8">out_code,&quot;case &quot;, convert(P,string), &quot;:\134n{\134n&quot;, input[P], &quot;}\134n&quot;):</Font>
            end:
        end:
        out_code := cat(<Font encoding="UTF-8">out_code, &quot;}\134n&quot;):
</Font>    else
        out_code := input[1]:
    end:
    if (append_code&lt;&gt;&quot;&quot;) then
        out_code := cat(out_code, append_code):
    end:
    out_code:
end:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">diF := proc(expr, symb) _diF(expr, symb) end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_diF := proc(expr, symb)
local tmp;
   tmp := eval(subs(symb = _MAVERICK_TMP_DIF, expr)):
   tmp := diff(tmp, _MAVERICK_TMP_DIF):
   tmp := subs(_MAVERICK_TMP_DIF = symb, tmp):
   tmp:
end proc:

</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end: <Font style="Text">module maverick utils</Font></Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib( 'MaverickUtils' );</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Constructor module</Text-field></Title>
<Group hide-output="false" labelreference="L552" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenConstructor := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local _fillConstructor;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export fillConstructor;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">fillConstructor := proc() _fillConstructor() end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_fillConstructor := proc()
local tmp_str, tmp_str_short, i_s, P:

<Font style="Text">states
</Font>tmp_str := &quot;_states_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_x = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;states&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;states_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;states&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over states</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;states&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">controls
</Font>tmp_str := &quot;_controls_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_u = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;controls&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;controls_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;controls&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over controls</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,&quot;  &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;controls&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_CONTROL_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_CONTROL_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">algebraic states
</Font>tmp_str := &quot;_algebraic_states_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_ax = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;algebraic_states&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;algebraic_states_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;algebraic_states&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over states</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;algebraic_states&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_STATE_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_STATE_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">algebraic controls
</Font>tmp_str := &quot;_algebraic_controls_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_au = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;algebraic_controls&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;algebraic_controls_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;algebraic_controls&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over controls</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,&quot;  &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;algebraic_controls&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_CONTROL_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_CONTROL_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">parameters
</Font>tmp_str := &quot;_parameters_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_p = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;params&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;params_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;params&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;params&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PARAM_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_PARAM_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">point constraints
</Font>tmp_str := &quot;_point_constraints_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_poc = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;point_constraints_nab&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;point_constraints_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;point_constraints_nab&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;point_constraints&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">integral constraints
</Font>tmp_str := &quot;_integral_constraints_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_ic = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;integral_constraints_nab&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;integral_constraints_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;integral_constraints_nab&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;integral_constraints&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">path constraints
</Font>tmp_str := &quot;_path_constraints_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_pc = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;diff_constraints_nab&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;diff_constraints_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;diff_constraints_nab&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;diff_constraints&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">boundary conditions
</Font>tmp_str := &quot;_boundary_conditions_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_bc = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;boundary_conditions_nab&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;boundary_conditions_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;boundary_conditions_nab&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;boundary_conditions&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_BC_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_BC_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">event constraints
</Font>tmp_str := &quot;_event_constraints_names = { &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;_dim_ec = {&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;event_constraints_nab&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;event_constraints_nab&quot;][i_s<Font encoding="UTF-8">][1], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;event_constraints_nab&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;event_constraints&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;} };&quot;):<Font style="Text">
</Font>tmp_str_short := cat(tmp_str_short, &quot;};&quot;):<Font style="Text">
</Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_EVENT_CONSTRAINT_DIM_VECTOR&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_EVENT_CONSTRAINT_NAMES_VECTOR&quot;,tmp_str);

<Font style="Text">post processing
</Font>tmp_str := &quot; &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;post_processing&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;post_processing&quot;][i_s<Font encoding="UTF-8">][2], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;post_processing&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;post_processing&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;}&quot;):<Font style="Text">
</Font>#replaceInTemplateCC(&quot;_MAVERICK_ENTER_POST_PROC_DIM&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_POST_PROC_NAMES&quot;,tmp_str);

<Font style="Text">differential post processing
</Font>tmp_str := &quot; &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;differential_post_processing&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;differential_post_processing&quot;][i_s<Font encoding="UTF-8">][2], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;differential_post_processing&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;differential_post_processing&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;}&quot;):<Font style="Text">
</Font>#replaceInTemplateCC(&quot;_MAVERICK_ENTER_DIFFERENTIAL_POST_PROC_DIM&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_DIFFERENTIAL_POST_PROC_NAMES&quot;,tmp_str);

<Font style="Text">integral post processing
</Font>tmp_str := &quot; &quot;:<Font style="Text">
</Font>tmp_str_short := &quot;&quot;;<Font style="Text">
</Font>for P from 1 to __num_phases do
tmp_str := cat(tmp_str, &quot;{&quot;);
for i_s from 1 to nops(__OCP[P][&quot;integral_post_processing&quot;]) do
   tmp_str := cat(tmp_str<Font encoding="UTF-8">, &quot;\134&quot;&quot;, </Font>__OCP[P][&quot;integral_post_processing&quot;][i_s<Font encoding="UTF-8">][2], &quot;\134&quot;&quot;):
</Font>   if (i_s&lt;nops(__OCP[P][&quot;integral_post_processing&quot;])) then tmp_str := cat(tmp_str,&quot;, &quot;): end:
end: <Font style="Text">loop over parameters</Font>
<Font encoding="UTF-8">if (P&lt;__num_phases) then tmp_str := cat(tmp_str,&quot;},\134n&quot;,__tabs,</Font>__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,__tabs,&quot; &quot;): end:
tmp_str_short := cat(tmp_str_short, convert(nops(__OCP[P][&quot;integral_post_processing&quot;]),string) );
if (P&lt;__num_phases) then tmp_str_short := cat(tmp_str_short,&quot;, &quot;): end:
end: <Font style="Text">loop over phases
</Font>tmp_str := cat(tmp_str, &quot;}&quot;):<Font style="Text">
</Font>#replaceInTemplateCC(&quot;_MAVERICK_ENTER_INTEGRAL_POST_PROC_DIM&quot;, tmp_str_short );    
replaceInTemplateCC(&quot;_MAVERICK_ENTER_INTEGRAL_POST_PROC_NAMES&quot;,tmp_str);

end:</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end module:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenConstructor');</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Bounds module</Text-field></Title>
<Group hide-output="false" labelreference="L555" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenBounds := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local _fillBounds, generateMultiPhaseVector;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs, __debug;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export fillBounds;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">generateMultiPhaseVector := proc(input, dim:=__num_phases)
    local P, out:
    out := &quot;{ &quot;:
    for P from 1 to dim do
        out := cat(out, input[P]):
<Font encoding="UTF-8">        if (P&lt;__num_phases) then out := cat(out, &quot;,\134n&quot;,__tabs,</Font>__tabs,__tabs,&quot;  &quot;): end:
    end do:
    out := cat(out, &quot; };&quot;):
    out:
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">fillBounds := proc() _fillBounds() end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_fillBounds := proc()
    local tmp_str, tmp_str_short, i_s, P, lower_values, upper_values, tmp_code_lower, tmp_code_upper, tmp_lower, tmp_upper, tmp, nx:
    
    <Font style="Text">states and controls</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;states_nab&quot;]:
        nx := nops(tmp):
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
</Font>        tmp := __OCP[P][&quot;controls_nab&quot;]:
        nx := nx + nops(tmp):
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s+nops(__OCP[P][&quot;states_nab&quot;])] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s+nops(__OCP[P][&quot;states_nab&quot;])] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp)+nops(__OCP[P][&quot;states_nab&quot;])<Font encoding="UTF-8">,string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp)+nops(__OCP[P][&quot;states_nab&quot;])<Font encoding="UTF-8">,string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nx &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONTROL_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nx &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONTROL_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">algebraic states and controls</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;algebraic_states_nab&quot;]:
        nx := nops(tmp):
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
</Font>        tmp := __OCP[P][&quot;algebraic_controls_nab&quot;]:
        nx := nx + nops(tmp):
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s+nops(__OCP[P][&quot;algebraic_states_nab&quot;])] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s+nops(__OCP[P][&quot;algebraic_states_nab&quot;])] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp)+nops(__OCP[P][&quot;algebraic_states_nab&quot;])<Font encoding="UTF-8">,string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp)+nops(__OCP[P][&quot;algebraic_states_nab&quot;])<Font encoding="UTF-8">,string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nx &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_STATE_CONTROL_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
     tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nx &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_ALG_STATE_CONTROL_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">parameters</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;params_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PARAMETER_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PARAMETER_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">point constraints</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;point_constraints_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">diff constraints</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;diff_constraints_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">integral constraints</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;integral_constraints_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">boundary conditions</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;boundary_conditions_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
    </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

    <Font style="Text">event constraints</Font>
    tmp_code_lower := 'tmp_code_lower': tmp_code_upper := 'tmp_code_upper':
    for P from 1 to __num_phases do
        tmp_lower := []:
        tmp_upper := []:
        tmp := __OCP[P][&quot;event_constraints_nab&quot;]:
        for i_s from 1 to nops(tmp) do
            tmp_lower := [op(tmp_lower), lower[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][2]) ]:
            tmp_upper := [op(tmp_upper), upper[i_s] = MaverickCodegen:-ocp2nlp(P,tmp[i_s][3]) ]:
        end do: <Font style="Text">loop over vars
        </Font>tmp_code_lower[P] := MaverickCodegen:-generateCode(tmp_lower, &quot;lower&quot;):<Font style="Text">
        </Font>#tmp_code_lower[P] := cat(&quot;lower = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_lower</Font>[P]):<Font style="Text">
        </Font>tmp_code_upper[P] := MaverickCodegen:-generateCode(tmp_upper, &quot;upper&quot;):<Font style="Text">
        </Font>#tmp_code_upper[P] := cat(&quot;upper = std::vector&lt;real&gt;(&quot;, convert(nops(tmp<Font encoding="UTF-8">),string) ,&quot;,0);\134n&quot; , tmp_code_upper[P]):</Font><Font style="Text">
     </Font>end do: <Font style="Text">loop over phases
     </Font>tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, getCodeForPhases(tmp_code_lower), __tabs, &quot;}\134n&quot;):</Font><Font style="Text">
     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:<Font style="Text">
     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_EVENT_CONSTRAINTS_BOUNDS_LOWER_VECTOR&quot;, tmp_str ):
   tmp_str := cat(&quot;{<Font encoding="UTF-8">\134n&quot;, </Font>getCodeForPhases(tmp_code_upper<Font encoding="UTF-8">), __tabs, &quot;}\134n&quot;):</Font>
<Font style="Text">     </Font>if (nops(tmp) &lt; 1 ) then tmp_str := &quot;&quot;: end:
<Font style="Text">     </Font>replaceInTemplateCC(&quot;_MAVERICK_ENTER_EVENT_CONSTRAINTS_BOUNDS_UPPER_VECTOR&quot;, tmp_str ):

end:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end module:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenBounds');</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Mayer and lagrange target module</Text-field></Title>
<Group hide-output="false" labelreference="L562" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenTarget := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local _writeTarget,
       writeMayer,
       writeLagrange;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export writeTarget;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeTarget := proc() writeMayer(): writeLagrange(): end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeMayer := proc()
    local P, nlp_may_tgt, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, may_j_xu_i, may_j_xu_f, may_j_p, may_jac,
          tmp_code_rows, tmp_code_cols, may_hess, hessian, may_hess_xu_init_xu_init, may_hess_xu_init_xu_fin, may_hess_xu_init_p,
          may_hess_xu_fin_xu_fin, may_hess_xu_fin_p, may_hess_p_p:

    <Font style="Text">mayer tgt
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_may_tgt[P] := MaverickCodegen:-ocp2nlp(P, __OCP[P][&quot;mayer_target&quot;]);
        tmp_code[P] := MaverickCodegen:-generateCode([ __value = nlp_may_tgt[P] ], &quot;value&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">mayer jacobian
    </Font>tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, may_j_xu_i[P] := getJacobianAndStructure([nlp_may_tgt[P]], __NLP[P][&quot;i_vars&quot;], __jac_xu_init);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_XUINIT_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_XUINIT_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, may_j_xu_f[P] := getJacobianAndStructure([nlp_may_tgt[P]], __NLP[P][&quot;f_vars&quot;], __jac_xu_fin);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, may_j_p[P] := getJacobianAndStructure([nlp_may_tgt[P]], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        may_jac[P] := [ op(may_j_xu_i[P]), op(may_j_xu_f[P]), op(may_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(may_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">mayer hessian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_xu_init_xu_init[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;i_vars&quot;], __hess_xu_init_xu_init );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUINIT_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUINIT_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUINIT_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_xu_init_xu_fin[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;f_vars&quot;], __hess_xu_init_xu_fin );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUFIN_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_xu_init_p[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_init_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUINIT_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_xu_fin_xu_fin[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;f_vars&quot;], __NLP[P][&quot;f_vars&quot;], __hess_xu_fin_xu_fin );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_XUFIN_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_xu_fin_p[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;f_vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_fin_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_XUFIN_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, may_hess_p_p[P] := getHessianAndStructure(nlp_may_tgt[P] * __lambda_0, __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    may_hess := 'may_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        may_hess[P] := [ op(may_hess_xu_init_xu_init[P]), op(may_hess_xu_init_xu_fin[P]), op(may_hess_xu_init_p[P]), op(may_hess_xu_fin_xu_fin[P]), op(may_hess_xu_fin_p[P]), op(may_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(may_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_MAYER_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write mayer</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeLagrange := proc()
    local P, nlp_lag_tgt, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, lag_j_xu, lag_j_dxu, lag_j_axu, lag_j_p, lag_jac,
          tmp_code_rows, tmp_code_cols, lag_hess, hessian, lag_hess_xu_xu, lag_hess_xu_dxu, lag_hess_xu_axu, lag_hess_xu_p,
          lag_hess_dxu_dxu, lag_hess_dxu_axu, lag_hess_dxu_p,
          lag_hess_axu_axu, lag_hess_axu_p,
          lag_hess_p_p:

    <Font style="Text">lagrange tgt
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_lag_tgt[P] := MaverickCodegen:-ocp2nlp(P, __OCP[P][&quot;lagrange_target&quot;]);
        tmp_code[P] := MaverickCodegen:-generateCode([ __value = nlp_lag_tgt[P] ], &quot;value&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">lagrange jacobian
    </Font>tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, lag_j_xu[P] := getJacobianAndStructure([nlp_lag_tgt[P]], __NLP[P][&quot;vars&quot;], __jac_xu);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, lag_j_dxu[P] := getJacobianAndStructure([nlp_lag_tgt[P]], __NLP[P][&quot;diff_vars&quot;], __jac_dxu);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, lag_j_axu[P] := getJacobianAndStructure([nlp_lag_tgt[P]], __NLP[P][&quot;alg_vars&quot;], __jac_axu);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, lag_j_p[P] := getJacobianAndStructure([nlp_lag_tgt[P]], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        lag_jac[P] := [ op(lag_j_xu[P]), op(lag_j_dxu[P]), op(lag_j_axu[P]), op(lag_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(lag_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">lagrange hessian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_xu_xu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;vars&quot;], __NLP[P][&quot;vars&quot;], __hess_xu_xu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_xu_dxu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_xu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_xu_axu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_xu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_xu_p[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_XU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_dxu_dxu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_dxu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_dxu_axu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_dxu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_dxu_p[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;params&quot;], __hess_dxu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_DXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_axu_axu[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_axu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_axu_p[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;params&quot;], __hess_axu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_AXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, lag_hess_p_p[P] := getHessianAndStructure(nlp_lag_tgt[P] * __lambda_0, __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    lag_hess := 'lag_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        lag_hess[P] := [ op(lag_hess_xu_xu[P]), op(lag_hess_xu_dxu[P]), op(lag_hess_xu_axu[P]), op(lag_hess_xu_p[P]), 
                         op(lag_hess_dxu_dxu[P]), op(lag_hess_dxu_axu[P]), op(lag_hess_dxu_p[P]), 
                         op(lag_hess_axu_axu[P]), op(lag_hess_axu_p[P]),
                         op(lag_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(lag_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_LAGRANGE_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write lagrange
</Font></Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end module:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenTarget');</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">First order equation module</Text-field></Title>
<Group hide-output="false" labelreference="L571" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenFoEqns := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local _writeFoEqns;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs,__debug;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export writeFoEqns;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeFoEqns := proc() _writeFoEqns(): end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_writeFoEqns := proc()
    local P, i, nlp_fo_eqns, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, foeqns_j_xu, foeqns_j_dxu, foeqns_j_axu, foeqns_j_p, foeqns_jac,
          tmp_code_rows, tmp_code_cols, foeqns_hess, hessian, 
          foeqns_hess_xu_xu, foeqns_hess_xu_dxu, foeqns_hess_xu_axu, foeqns_hess_xu_p,
          foeqns_hess_dxu_dxu, foeqns_hess_dxu_axu, foeqns_hess_dxu_p, 
          foeqns_hess_axu_axu, foeqns_hess_axu_p,
          foeqns_hess_p_p, nlp_fo_eqns_expr, fo_eqns_hess:

    <Font style="Text">foeqns 
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_fo_eqns[P] := MaverickCodegen:-ocp2nlp(P, __OCP[P][&quot;fo_eqns&quot;]);
        for i from 1 to nops(nlp_fo_eqns[P]) do nlp_fo_eqns_expr[P][i] := __values[i] = nlp_fo_eqns[P][i]: end do:
        if ( nops(nlp_fo_eqns[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            #tmp_code[P] := MaverickCodegen:-generateCode( nlp_fo_eqns_expr[P] , &quot;__values&quot;);
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_fo_eqns_expr[P],list), &quot;__values&quot;);
        end:
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">foeqns jacobian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
          
    </Font>    jacobian, nnz, C_iRows, C_iCols, foeqns_j_xu[P] := getJacobianAndStructure( nlp_fo_eqns[P], __NLP[P][&quot;vars&quot;], __jac_xu);

<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">      tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   

    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, foeqns_j_dxu[P] := getJacobianAndStructure(nlp_fo_eqns[P], __NLP[P][&quot;diff_vars&quot;], __jac_dxu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, foeqns_j_axu[P] := getJacobianAndStructure(nlp_fo_eqns[P], __NLP[P][&quot;alg_vars&quot;], __jac_axu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, foeqns_j_p[P] := getJacobianAndStructure(nlp_fo_eqns[P], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        foeqns_jac[P] := [ op(foeqns_j_xu[P]), op(foeqns_j_dxu[P]), op(foeqns_j_axu[P]), op(foeqns_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(foeqns_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">foeqns hessian
    </Font>for P from 1 to __num_phases do<Font style="Text">
        </Font>fo_eqns_hess[P] := 0:
    <Font style="Text">    </Font>for i from 1 to nops(nlp_fo_eqns[P]) do
    <Font style="Text">    </Font>    fo_eqns_hess[P] := fo_eqns_hess[P] + nlp_fo_eqns[P][i] * __lambda[i];
    <Font style="Text">    </Font>end do:<Font style="Text">
    </Font>end:<Font style="Text">

    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_xu_xu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;vars&quot;], __hess_xu_xu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_xu_dxu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_xu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_xu_axu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_xu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_xu_p[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_XU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_dxu_dxu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_dxu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_dxu_axu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_dxu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_dxu_p[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;params&quot;], __hess_dxu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_DXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_axu_axu[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_axu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_axu_p[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;params&quot;], __hess_axu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_AXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, foeqns_hess_p_p[P] := getHessianAndStructure(fo_eqns_hess[P], __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    foeqns_hess := 'foeqns_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        foeqns_hess[P] := [ op(foeqns_hess_xu_xu[P]), op(foeqns_hess_xu_dxu[P]), op(foeqns_hess_xu_axu[P]), op(foeqns_hess_xu_p[P]), 
                         op(foeqns_hess_dxu_dxu[P]), op(foeqns_hess_dxu_axu[P]), op(foeqns_hess_dxu_p[P]), 
                         op(foeqns_hess_axu_axu[P]), op(foeqns_hess_axu_p[P]),
                         op(foeqns_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(foeqns_hess[P], &quot;hess&quot;);
    end:

    replaceInTemplateCC(&quot;_MAVERICK_ENTER_FO_EQNS_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write diff_constr
</Font></Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end module:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenFoEqns');</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Constraints module</Text-field></Title>
<Group hide-output="false" labelreference="L575" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenConstraints := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local writePointConstrants, writeDiffConstrants, writeIntConstrants;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs, __debug;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export writeConstraints;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeConstraints := proc() writePointConstrants(): writeDiffConstrants(): writeIntConstrants(): end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writePointConstrants := proc()
    local P, i, nlp_point_constr, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, point_constr_j_xu, point_constr_j_dxu, point_constr_j_p, point_constr_jac,
          tmp_code_rows, tmp_code_cols, hessian, point_constr_hess_xu_xu, point_constr_hess_xu_dxu, point_constr_hess_xu_p,
          point_constr_hess_dxu_dxu, point_constr_hess_dxu_p, point_constr_hess_p_p, nlp_point_constr_expr, point_constr_hess:

   <Font style="Text">point_constr 
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_point_constr[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;point_constraints&quot;][i],i=1..nops(__OCP[P][&quot;point_constraints&quot;]) )] );
        for i from 1 to nops(nlp_point_constr[P]) do nlp_point_constr_expr[P][i] := __values[i] = nlp_point_constr[P][i]: end do:
        if ( nops(nlp_point_constr[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_point_constr_expr[P],list), &quot;__values&quot;);
        end:
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">point_constr jacobian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, point_constr_j_xu[P] := getJacobianAndStructure( nlp_point_constr[P], __NLP[P][&quot;vars&quot;], __jac_xu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">      tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, point_constr_j_p[P] := getJacobianAndStructure(nlp_point_constr[P], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        point_constr_jac[P] := [ op(point_constr_j_xu[P]), op(point_constr_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(point_constr_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">point_constr hessian
    </Font>for P from 1 to __num_phases do<Font style="Text">
        </Font>point_constr_hess[P] := 0:
    <Font style="Text">    </Font>for i from 1 to nops(nlp_point_constr[P]) do
    <Font style="Text">    </Font>    point_constr_hess[P] := point_constr_hess[P] + nlp_point_constr[P][i] * __lambda[i];
    <Font style="Text">    </Font>end do:<Font style="Text">
    </Font>end:<Font style="Text">

    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, point_constr_hess_xu_xu[P] := getHessianAndStructure(point_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;vars&quot;], __hess_xu_xu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, point_constr_hess_xu_p[P] := getHessianAndStructure(point_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_XU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, point_constr_hess_p_p[P] := getHessianAndStructure(point_constr_hess[P], __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    point_constr_hess := 'point_constr_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        point_constr_hess[P] := [ op(point_constr_hess_xu_xu[P]), op(point_constr_hess_xu_p[P]), op(point_constr_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(point_constr_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_STATE_CONSTRAINTS_H_BODY&quot;, getCodeForPhases(tmp_code) ):

end: <Font style="Text">end write point constr</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeDiffConstrants := proc()
    local P, i, nlp_diff_constr, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, diff_constr_j_xu, diff_constr_j_dxu, diff_constr_j_axu, diff_constr_j_p, diff_constr_jac,
          tmp_code_rows, tmp_code_cols, hessian, 
          diff_constr_hess_xu_xu, diff_constr_hess_xu_dxu, diff_constr_hess_xu_axu, diff_constr_hess_xu_p,
          diff_constr_hess_dxu_dxu, diff_constr_hess_dxu_axu, diff_constr_hess_dxu_p, 
          diff_constr_hess_axu_axu, diff_constr_hess_axu_p,
          diff_constr_hess_p_p, nlp_diff_constr_expr, diff_constr_hess:

   <Font style="Text">diff_constr 
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_diff_constr[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;diff_constraints&quot;][i],i=1..nops(__OCP[P][&quot;diff_constraints&quot;]) )] );
        for i from 1 to nops(nlp_diff_constr[P]) do nlp_diff_constr_expr[P][i] := __values[i] = nlp_diff_constr[P][i]: end do:
        if ( nops(nlp_diff_constr[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_diff_constr_expr[P],list), &quot;__values&quot;);
        end:
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">diff_constr jacobian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, diff_constr_j_xu[P] := getJacobianAndStructure( nlp_diff_constr[P], __NLP[P][&quot;vars&quot;], __jac_xu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">      tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, diff_constr_j_dxu[P] := getJacobianAndStructure(nlp_diff_constr[P], __NLP[P][&quot;diff_vars&quot;], __jac_dxu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, diff_constr_j_axu[P] := getJacobianAndStructure(nlp_diff_constr[P], __NLP[P][&quot;alg_vars&quot;], __jac_axu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, diff_constr_j_p[P] := getJacobianAndStructure(nlp_diff_constr[P], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        diff_constr_jac[P] := [ op(diff_constr_j_xu[P]), op(diff_constr_j_dxu[P]), op(diff_constr_j_axu[P]), op(diff_constr_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(diff_constr_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">diff_constr hessian
    </Font>for P from 1 to __num_phases do<Font style="Text">
        </Font>diff_constr_hess[P] := 0:
    <Font style="Text">    </Font>for i from 1 to nops(nlp_diff_constr[P]) do
    <Font style="Text">    </Font>    diff_constr_hess[P] := diff_constr_hess[P] + nlp_diff_constr[P][i] * __lambda[i];
    <Font style="Text">    </Font>end do:<Font style="Text">
    </Font>end:<Font style="Text">

    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_xu_xu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;vars&quot;], __hess_xu_xu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_xu_dxu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_xu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_xu_axu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_xu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_xu_p[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_XU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_dxu_dxu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_dxu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_dxu_axu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_dxu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_dxu_p[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;params&quot;], __hess_dxu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_DXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_axu_axu[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_axu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_axu_p[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;params&quot;], __hess_axu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_AXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, diff_constr_hess_p_p[P] := getHessianAndStructure(diff_constr_hess[P], __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    diff_constr_hess := 'diff_constr_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        diff_constr_hess[P] := [ op(diff_constr_hess_xu_xu[P]), op(diff_constr_hess_xu_dxu[P]), op(diff_constr_hess_xu_axu[P]), op(diff_constr_hess_xu_p[P]), 
                         op(diff_constr_hess_dxu_dxu[P]), op(diff_constr_hess_dxu_axu[P]), op(diff_constr_hess_dxu_p[P]), 
                         op(diff_constr_hess_axu_axu[P]), op(diff_constr_hess_axu_p[P]),
                         op(diff_constr_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(diff_constr_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_PATH_CONSTR_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write diff_constr
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeIntConstrants := proc()
    local P, i, nlp_int_constr, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, int_constr_j_xu, int_constr_j_dxu, int_constr_j_axu, int_constr_j_p, int_constr_jac,
          tmp_code_rows, tmp_code_cols, hessian, 
          int_constr_hess_xu_xu, int_constr_hess_xu_dxu, int_constr_hess_xu_axu, int_constr_hess_xu_p,
          int_constr_hess_dxu_dxu, int_constr_hess_dxu_axu, int_constr_hess_dxu_p,
          int_constr_hess_axu_axu, int_constr_hess_axu_p,
          int_constr_hess_p_p, nlp_int_constr_expr, int_constr_hess:

   <Font style="Text">int_constr 
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_int_constr[P] := MaverickCodegen:-ocp2nlp(P,  [seq(__OCP[P][&quot;integral_constraints&quot;][i],i=1..nops(__OCP[P][&quot;integral_constraints&quot;]) )] );
        for i from 1 to nops(nlp_int_constr[P]) do nlp_int_constr_expr[P][i] := __values[i] = nlp_int_constr[P][i]: end do:
        if ( nops(nlp_int_constr[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_int_constr_expr[P],list), &quot;__values&quot;);
        end:
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">int_constr jacobian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, int_constr_j_xu[P] := getJacobianAndStructure( nlp_int_constr[P], __NLP[P][&quot;vars&quot;], __jac_xu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">      tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, int_constr_j_dxu[P] := getJacobianAndStructure(nlp_int_constr[P], __NLP[P][&quot;diff_vars&quot;], __jac_dxu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, int_constr_j_axu[P] := getJacobianAndStructure(nlp_int_constr[P], __NLP[P][&quot;alg_vars&quot;], __jac_axu);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, int_constr_j_p[P] := getJacobianAndStructure(nlp_int_constr[P], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        int_constr_jac[P] := [ op(int_constr_j_xu[P]), op(int_constr_j_dxu[P]), op(int_constr_j_axu[P]), op(int_constr_j_p[P]), op(int_constr_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(int_constr_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">int_constr hessian
    </Font>for P from 1 to __num_phases do<Font style="Text">
        </Font>int_constr_hess[P] := 0:
    <Font style="Text">    </Font>for i from 1 to nops(nlp_int_constr[P]) do
    <Font style="Text">    </Font>    int_constr_hess[P] := int_constr_hess[P] + nlp_int_constr[P][i] * __lambda[i];
    <Font style="Text">    </Font>end do:<Font style="Text">
    </Font>end:<Font style="Text">

    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_xu_xu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;vars&quot;], __hess_xu_xu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_XU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_XU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_XU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_xu_dxu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_xu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_xu_axu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_xu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_xu_p[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_XU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_dxu_dxu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;diff_vars&quot;], __hess_dxu_dxu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_DXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_DXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_DXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_dxu_axu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_dxu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_dxu_p[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;diff_vars&quot;], __NLP[P][&quot;params&quot;], __hess_dxu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_DXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_axu_axu[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;alg_vars&quot;], __hess_axu_axu );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_AXU_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_AXU_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_AXU_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_axu_p[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;alg_vars&quot;], __NLP[P][&quot;params&quot;], __hess_axu_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_AXU_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, int_constr_hess_p_p[P] := getHessianAndStructure(int_constr_hess[P], __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    int_constr_hess := 'int_constr_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        int_constr_hess[P] := [ op(int_constr_hess_xu_xu[P]), op(int_constr_hess_xu_dxu[P]), op(int_constr_hess_xu_axu[P]), op(int_constr_hess_xu_p[P]), 
                         op(int_constr_hess_dxu_dxu[P]), op(int_constr_hess_dxu_axu[P]), op(int_constr_hess_dxu_p[P]), 
                         op(int_constr_hess_axu_axu[P]), op(int_constr_hess_axu_p[P]),
                         op(int_constr_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(int_constr_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_INT_CONSTR_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write int_constr</Font>
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end module:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenConstraints');</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Bcs and event constraints module</Text-field></Title>
<Group hide-output="false" labelreference="L578" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenBcs := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local writeBcs, writeEventConstrants;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs, __debug;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export writeBcsAndEventConstraints;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeBcsAndEventConstraints := proc() writeBcs(): writeEventConstrants(): end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeBcs := proc()
    local P, i, nlp_bcs, tmp_code, tmp_nnz, jacobian, nnz, C_iRows, C_iCols, bcs_j_xu_init, bcs_j_xu_fin, bcs_j_p, bcs_jac,
          tmp_code_rows, tmp_code_cols, hessian, bcs_hess_xu_init_xu_init, bcs_hess_xu_init_xu_fin, bcs_hess_xu_init_p,
          bcs_hess_xu_fin_xu_fin, bcs_hess_xu_fin_p, bcs_hess_p_p, nlp_bcs_expr, bcs_hess:

   <Font style="Text">bcs 
    </Font>for P from 1 to __num_phases do<Font style="Text">
</Font>        nlp_bcs[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;boundary_conditions&quot;][i],i=1..nops(__OCP[P][&quot;boundary_conditions&quot;]) )] );
        for i from 1 to nops(nlp_bcs[P]) do nlp_bcs_expr[P][i] := __values[i] = nlp_bcs[P][i]: end do:
        if ( nops(nlp_bcs[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_bcs_expr[P],list), &quot;__values&quot;);
        end:
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">bcs jacobian
    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, bcs_j_xu_init[P] := getJacobianAndStructure( nlp_bcs[P], __NLP[P][&quot;i_vars&quot;], __jac_xu_init);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">      tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUINIT_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUINIT_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUINIT_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, bcs_j_xu_fin[P] := getJacobianAndStructure(nlp_bcs[P], __NLP[P][&quot;f_vars&quot;], __jac_xu_fin);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUFIN_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

<Font style="Text">    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    jacobian, nnz, C_iRows, C_iCols, bcs_j_p[P] := getJacobianAndStructure(nlp_bcs[P], __NLP[P][&quot;params&quot;], __jac_p);
<Font style="Text">    </Font>    tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font style="Text">    </Font>    tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:   
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        bcs_jac[P] := [ op(bcs_j_xu_init[P]), op(bcs_j_xu_fin[P]), op(bcs_j_p[P]) ];
        tmp_code[P] := MaverickCodegen:-generateCode(bcs_jac[P], &quot;jac&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_J_BODY&quot;, getCodeForPhases(tmp_code) ):

    <Font style="Text">bcs hessian
    </Font>for P from 1 to __num_phases do<Font style="Text">
        </Font>bcs_hess[P] := 0:
    <Font style="Text">    </Font>for i from 1 to nops(nlp_bcs[P]) do
    <Font style="Text">    </Font>    bcs_hess[P] := bcs_hess[P] + nlp_bcs[P][i] * __lambda[i];
    <Font style="Text">    </Font>end do:<Font style="Text">
    </Font>end:<Font style="Text">

    </Font>tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_xu_init_xu_init[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;i_vars&quot;], __hess_xu_init_xu_init );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUINIT_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUINIT_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUINIT_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_xu_init_xu_fin[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;f_vars&quot;], __hess_xu_init_xu_fin );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUFIN_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_xu_init_p[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;i_vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_init_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUINIT_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_xu_fin_xu_fin[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;f_vars&quot;], __NLP[P][&quot;f_vars&quot;], __hess_xu_fin_xu_fin );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_XUFIN_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_XUFIN_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_XUFIN_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_xu_fin_p[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;f_vars&quot;], __NLP[P][&quot;params&quot;], __hess_xu_fin_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">       tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_XUFIN_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code_rows := 'tmp_code_rows':<Font style="Text">
    </Font>tmp_code_cols := 'tmp_code_cols':<Font style="Text">
    </Font>tmp_nnz := 'tmp_nnz':<Font style="Text">
    </Font>for P from 1 to __num_phases do<Font style="Text">
    </Font>    hessian, nnz, C_iRows, C_iCols, bcs_hess_p_p[P] := getHessianAndStructure(bcs_hess[P], __NLP[P][&quot;params&quot;], __NLP[P][&quot;params&quot;], __hess_p_p );
        tmp_code_rows[P] := MaverickCodegen:-generateCode(C_iRows, &quot;rows&quot;);   
        tmp_code_cols[P] := MaverickCodegen:-generateCode(C_iCols, &quot;cols&quot;);
<Font encoding="UTF-8">        tmp_nnz[P] := cat(&quot;return &quot;, convert(nnz,string), &quot;;\134n&quot;):
</Font>    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_P_P_NNZ&quot;, getCodeForPhases(tmp_nnz, &quot;return 0;&quot;) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_P_P_ROW_PATTERN&quot;, getCodeForPhases(tmp_code_rows) ):
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_P_P_COL_PATTERN&quot;, getCodeForPhases(tmp_code_cols) ):

    tmp_code := 'tmp_code':
    bcs_hess := 'bcs_hess':
<Font style="Text">    </Font>for P from 1 to __num_phases do
        bcs_hess[P] := [ op(bcs_hess_xu_init_xu_init[P]), op(bcs_hess_xu_init_xu_fin[P]), op(bcs_hess_xu_init_p[P]), op(bcs_hess_xu_fin_xu_fin[P]), op(bcs_hess_xu_fin_p[P]), op(bcs_hess_p_p[P])];
        tmp_code[P] := MaverickCodegen:-generateCode(bcs_hess[P], &quot;hess&quot;);
    end:
    replaceInTemplateCC(&quot;_MAVERICK_ENTER_BOUNDARY_CONDITIONS_H_BODY&quot;, getCodeForPhases(tmp_code) ):


end: <Font style="Text">end write bcs</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end: <Font style="Text">end module bcs and event constraints</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenBcs'):</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 2" layout="Heading 2">Post processing module</Text-field></Title>
<Group hide-output="false" labelreference="L579" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegenPostProc := module()</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected</Font>
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local writePP, writeDiffPP, writeIntPP;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __tabs, __debug;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export writePostProcessing;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writePostProcessing := proc() writePP(): writeDiffPP(), writeIntPP(): end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writePP := proc()
    local P, i, nlp_post_proc, tmp_code, nlp_post_proc_expr:

    tmp_code := 'tmp_code':
    for P from 1 to __num_phases do
        nlp_post_proc[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;post_processing&quot;][i][1], i=1..nops(__OCP[P][&quot;post_processing&quot;])) ] );

        #nlp_post_proc_expr[P] := []:
        #for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P] := [op(nlp_post_proc_expr[P]), __values[i] = nlp_post_proc[P][i]]: end do:
        for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P][i] := __values[i] = nlp_post_proc[P][i]: end do:
        if ( nops(nlp_post_proc[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_post_proc_expr[P],list), &quot;__values&quot;);
        end:
     end: <Font style="Text">loop over phases
</Font>     replaceInTemplateCC(&quot;_MAVERICK_ENTER_POST_PROC_BODY&quot;, getCodeForPhases(tmp_code) ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeDiffPP := proc()
    local P, i, nlp_post_proc, tmp_code,nlp_post_proc_expr:

    for P from 1 to __num_phases do
        nlp_post_proc[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;differential_post_processing&quot;][i][1], i=1..nops(__OCP[P][&quot;differential_post_processing&quot;])) ] );
      
        nlp_post_proc_expr[P] := []:
        for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P] := [op(nlp_post_proc_expr[P]), __values[i] = nlp_post_proc[P][i]]: end do:
        #for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P][i] := __values[i] = nlp_post_proc[P][i]: end do:
        if ( nops(nlp_post_proc[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_post_proc_expr[P],list), &quot;__values&quot;);
        end:
     end: <Font style="Text">loop over phases
</Font>     replaceInTemplateCC(&quot;_MAVERICK_ENTER_DIFFERENTIAL_POST_PROC_BODY&quot;, getCodeForPhases(tmp_code) ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeIntPP := proc()
    local P, i, nlp_post_proc, tmp_code,nlp_post_proc_expr:

    for P from 1 to __num_phases do
        nlp_post_proc[P] := MaverickCodegen:-ocp2nlp(P, [seq(__OCP[P][&quot;integral_post_processing&quot;][i][1], i=1..nops(__OCP[P][&quot;integral_post_processing&quot;])) ] );
      
        nlp_post_proc_expr[P] := []:
        for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P] := [op(nlp_post_proc_expr[P]), __values[i] = nlp_post_proc[P][i]]: end do:
        #for i from 1 to nops(nlp_post_proc[P]) do nlp_post_proc_expr[P][i] := __values[i] = nlp_post_proc[P][i]: end do:
        if ( nops(nlp_post_proc[P])=0 ) then 
            tmp_code[P] := &quot;&quot;:
        else
            tmp_code[P] := MaverickCodegen:-generateCode(convert(nlp_post_proc_expr[P],list), &quot;__values&quot;);
        end:
     end: <Font style="Text">loop over phases
</Font>     replaceInTemplateCC(&quot;_MAVERICK_ENTER_INTEGRAL_POST_PROC_BODY&quot;, getCodeForPhases(tmp_code) ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end: <Font style="Text">module pp</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib('MaverickCodegenPostProc'):</Text-field>
</Input>
</Group>
</Section>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Maverick code generation module</Text-field></Title>
<Group hide-output="false" labelreference="L550" drawlabel="true" applyint="true" applyrational="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MaverickCodegen := module()
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">uses MaverickUtils;
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">option package:  <Font style="Text">all exported names are automatically protected

</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __OCP, __num_phases, __mapped_maverick_objects, __mapped_objects, __mav_tmp_folder,
      __output_array_cc, __output_guess_array_cc, __output_array_hh, __output_guess_array_hh,
      __original_array_cc, __original_guess_array_cc, __original_array_hh, __original_guess_array_hh,
      __output_array_main_cc, __output_array_compile,
      __output_array_lib_hh, __output_array_lib_cc,
      __model_params_names_str, __model_params_index_defines, __model_params_convert, __num_model_params,
      __tabs,__debug:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local _maverick_ext_obj_includes_str,
      _maverick_ext_obj_def_strs,
      _maverick_ext_obj_namespace_strs,
      _maverick_ext_obj_setup_str,
      _maverick_ext_obj_print_str,
      _ext_obj_convert,
      _ext_object_language_defs,
      _class_name,

      __ocp_to_nlp_conv1, __ocp_to_nlp_conv2, __ocp_to_nlp_at_bc_conv,

      processMappedObjects,
      addVariableDeclaration,
      convertParamsAndFunctions,
      maverick_language_module,
      _generateCode,
      _ocp2nlp,
      initLanguageModule,
      writeGuess,
      loadTemplates,
      writeSourceFiles,
      _clearCode,
      _setConversion,
      writeParameters,
      writeFirst,
      writeMain,

      writeLibrary,
      writeCompile:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export  
       clearCode, 
       initCode, 
       setConversion,
       generateOcpCode,
       generateCode,
       ocp2nlp;

</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">initCode := proc()
    #__mav_tmp_folder := (currentdir(), &quot;/mav_tmp&quot;):
end:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">clearCode := proc() _clearCode(): end:
_clearCode := proc() 

    _maverick_ext_obj_includes_str := &quot;&quot;:
    _maverick_ext_obj_def_strs := &quot;&quot;:
    _maverick_ext_obj_namespace_strs := &quot;&quot;:
    _maverick_ext_obj_setup_str := &quot;&quot;:
    _maverick_ext_obj_print_str := &quot;&quot;;
    _ext_obj_convert := []:
    _ext_object_language_defs := []:

end:
   </Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">setConversion := proc(ocp_to_nlp_conv1, ocp_to_nlp_conv2, ocp_to_nlp_at_bc_conv)  _setConversion(ocp_to_nlp_conv1, ocp_to_nlp_conv2, ocp_to_nlp_at_bc_conv): end:
_setConversion := proc(ocp_to_nlp_conv1, ocp_to_nlp_conv2, ocp_to_nlp_at_bc_conv) 
    __ocp_to_nlp_conv1 := ocp_to_nlp_conv1:
    __ocp_to_nlp_conv2 := ocp_to_nlp_conv2:

    __ocp_to_nlp_at_bc_conv := ocp_to_nlp_at_bc_conv:
end:
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">ocp2nlp := proc( P::integer ) _ocp2nlp(P, seq(_passed[i],i=2.._npassed) ): end:
_ocp2nlp := proc( P::integer )
   seq(subs(op(__ocp_to_nlp_conv2[P]), op(__ocp_to_nlp_at_bc_conv[P]), subs(op(__ocp_to_nlp_conv1[P]), _passed[i])), i=2.._npassed);

end proc:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">loadTemplates := proc()
local filename, fid, line, template_cc, template_hh, template_guess_cc, template_guess_hh, mav_path:   

  mav_path := cat(kernelopts(mapledir),&quot;/toolbox/Maverick/templates/&quot;):</Text-field>
</Input>
<Input><Text-field style="Text" layout="Normal">    .CC template
    <Font style="Maple Input">filename := cat(mav_path,&quot;MaverickOcp.template.cc&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_cc := [op(template_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_cc := Array(template_cc):
    __original_array_cc := __output_array_cc:

</Font>    Guess .CC template
    <Font style="Maple Input">filename := cat(mav_path,&quot;MaverickOcpGuess.template.cc&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_guess_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_guess_cc := [op(template_guess_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_guess_array_cc := Array(template_guess_cc):
    __original_guess_array_cc := __output_guess_array_cc:

</Font>    .HH template
    <Font style="Maple Input">filename := cat(mav_path,&quot;MaverickOcp.template.hh&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_hh := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_hh := [op(template_hh), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_hh := Array(template_hh):
    __original_array_hh := __output_array_hh:

</Font>    Guess .HH template
    <Font style="Maple Input">filename := cat(mav_path,&quot;MaverickOcpGuess.template.hh&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_guess_hh := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_guess_hh := [op(template_guess_hh), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_guess_array_hh := Array(template_guess_hh):
    __original_guess_array_hh := __output_guess_array_hh:

</Font>    main .CC template
    <Font style="Maple Input">filename := cat(mav_path,&quot;MaverickMain.template.cc&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_cc := [op(template_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_main_cc := Array(template_cc):

    </Font>library .HH template
    <Font style="Maple Input">filename := cat(mav_path,&quot;Maverick_lib.template.h&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_cc := [op(template_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_lib_hh := Array(template_cc):

    </Font>library .HH template
    <Font style="Maple Input">filename := cat(mav_path,&quot;Maverick_lib.template.cc&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_cc := [op(template_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_lib_cc := Array(template_cc):

</Font>    compile template
    <Font style="Maple Input">filename := cat(mav_path,&quot;compile.template.sh&quot;);
</Font>    <Font style="Maple Input">fid := fopen(filename, READ);
</Font>    <Font style="Maple Input">line := readline(fid):
</Font>    <Font style="Maple Input">template_cc := []:
</Font>    <Font style="Maple Input">while not(line=0) do
       template_cc := [op(template_cc), line];
       line := readline(fid);
    end do:
    fclose(fid);
    __output_array_compile := Array(template_cc):
end:</Font>
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">processMappedObjects := proc()
    local objType, objCName, objCommonName, tmp, i_func, num_args, func_name, ext_func_name, i_arg, i_second_arg, obj, header, namespace, functions,first_part:

<Font style="Text">process maverick objects</Font>
for header in [indices(__mapped_maverick_objects,'nolist')] do
if (header&lt;&gt;&quot;__mav&quot;) then
     obj := __mapped_maverick_objects[header]:
     objType := obj[&quot;class_name&quot;]:
     objCName := obj[&quot;instance_name&quot;]:
     objCommonName := header:
     namespace := obj[&quot;namespace&quot;]:
     if (namespace&lt;&gt;&quot;&quot;) then
           tmp := cat(&quot;using namespace &quot;, namespace<Font encoding="UTF-8">, &quot;;\134n&quot;): </Font><Font style="Text">namepsace include</Font>
           if ( StringTools[Search](tmp,_maverick_ext_obj_namespace_strs)&lt;1 ) then
                 _maverick_ext_obj_namespace_strs := cat(_maverick_ext_obj_namespace_strs, tmp):
           end:
     end if:
     if (namespace&lt;&gt;&quot;&quot;) then
         _maverick_ext_obj_def_strs := cat(_maverick_ext_obj_def_strs,  __tabs, __tabs, &quot;std::unique_ptr&lt;&quot;,namespace,&quot;::&quot;,objType, &quot;Interface&gt; &quot;, objCName<Font encoding="UTF-8">, &quot; = nullptr;\134n&quot;):
</Font>     else
         _maverick_ext_obj_def_strs := cat(_maverick_ext_obj_def_strs,  __tabs, __tabs, &quot;std::unique_ptr&lt;&quot;,objType, &quot;Interface&gt; &quot;, objCName<Font encoding="UTF-8">, &quot; = nullptr;\134n&quot;):
</Font>     end:
     _maverick_ext_obj_setup_str := cat(_maverick_ext_obj_setup_str,
                                                       __tabs, objCName, &quot; = std::unique_ptr&lt;&quot;,objType, &quot;Interface&gt; (get&quot;, objType<Font encoding="UTF-8">, &quot;(\134&quot;&quot;, </Font>objCommonName<Font encoding="UTF-8">  , &quot;\134&quot;));\134n&quot;,
</Font>                                                       __tabs,<Font encoding="UTF-8">&quot;try {\134n&quot;,
</Font>                                                       __tabs,__tabs, &quot;<Font encoding="UTF-8">gc_function = &amp;( (*gc_mapped_objects)(\134&quot;&quot;,</Font>convert(objCommonName,string)<Font encoding="UTF-8">,&quot;\134&quot;) );\134n&quot;,</Font>
                                                       __tabs, &quot;<Font encoding="UTF-8">} catch (...) {\134n&quot;,
</Font>                                                       __tabs, __tabs, &quot;<Font encoding="UTF-8">throw std::runtime_error(\134&quot;Cannot find mapped object named '&quot;, </Font>convert(objCommonName,string) <Font encoding="UTF-8">,&quot;' in the lua data file\134\134n\134&quot;);\134n</Font>&quot;,
<Font encoding="UTF-8">                                                       __tabs, &quot;}\134n&quot;,</Font>
                                                       __tabs, objCName<Font encoding="UTF-8">, &quot;-&gt;setup(*gc_function);\134n\134n&quot;
</Font>                                                       );

    _maverick_ext_obj_print_str := cat(_maverick_ext_obj_print_str, 
<Font encoding="UTF-8">                                       __tabs, &quot;out &lt;&lt; \134&quot;\134\134n\134&quot;;\134n&quot;,</Font>
                                       __tabs, <Font encoding="UTF-8">objCName, &quot;-&gt;printInfo(out, info_level);\134n&quot;);
</Font>
    <Font encoding="UTF-8">tmp := cat(&quot;#include \134&quot;&quot;, </Font>obj[&quot;include&quot;]<Font encoding="UTF-8">, &quot;\134&quot;\134n&quot;): </Font><Font style="Text">namepsace include</Font>
    if ( StringTools[Search](tmp,_maverick_ext_obj_includes_str)&lt;1 ) then
          _maverick_ext_obj_includes_str := cat(_maverick_ext_obj_includes_str, tmp):
    end:

    <Font style="Text">Loop over the number of declared functions for this object</Font>
    functions := obj[&quot;functions&quot;]:
    for i_func from 1 to nops(functions) do
          <Font style="Text">number of arguments taken from this function</Font>
          num_args := nops(lhs( functions[i_func] )):
          func_name :=  op(0,lhs( functions[i_func] )):
          ext_func_name :=  op(0,rhs( functions[i_func] )):

          _ext_object_language_defs := [op(_ext_object_language_defs), [ func_name, num_args, ext_func_name, objCName ] ]:
          <Font style="Text">loop over the number of arguments</Font>
          for i_arg from 1 to num_args do
               _ext_obj_convert := [op(_ext_obj_convert), (D[i_arg](func_name))=cat(func_name ,_D_,i_arg)]:
               _ext_object_language_defs := [op(_ext_object_language_defs), [ cat(func_name ,_D_,i_arg), num_args, cat(ext_func_name ,_D_,i_arg) , objCName ] ]:
               for i_second_arg from (i_arg) to num_args do
                        _ext_obj_convert := [op(_ext_obj_convert), (D[i_arg,i_second_arg](func_name))=cat(func_name ,_D_,i_arg,_,i_second_arg)]:
                        _ext_object_language_defs := [op(_ext_object_language_defs), [ cat(func_name ,_D_,i_arg,_,i_second_arg), num_args, cat(ext_func_name ,_D_,i_arg,_,i_second_arg) , objCName ] ]:
               end do: <Font style="Text">end do second argument</Font>
          end do: <Font style="Text">end do i_arg</Font>
          
          <Font style="Text">If there is only one argument, then add also the expression for D(f) which my appears instead of D[1](f)
             </Font> if (num_args=1) then
              _ext_obj_convert := [op(_ext_obj_convert), (D(func_name))=cat(func_name ,_D_1)]:
              _ext_obj_convert := [op(_ext_obj_convert), (D@@2)(func_name)=cat(func_name ,_D_1_1)]:
              _ext_obj_convert := [op(_ext_obj_convert), (D@@3)(func_name)=cat(func_name ,_D_1_1_1)]:
          end:
    end do:  <Font style="Text">end do i_func</Font>
end: <Font style="Text">end if header&lt;&gt;__mav</Font>
end: <Font style="Text">end main for</Font>
#if ( nops(mapped_maverick_objects&gt;0) ) then <Font encoding="UTF-8">_maverick_ext_obj_includes_str := &quot;#include \134&quot;Maverick.hh\134&quot;&quot;: end:
</Font>
<Font style="Text">process custom objects</Font>
for header in [indices(__mapped_objects,'nolist')] do
if (header&lt;&gt;&quot;__mav&quot;) then
     obj := __mapped_objects[header]:
     objType := obj[&quot;class_name&quot;]:
     objCName := obj[&quot;instance_name&quot;]:
     objCommonName := header:
     namespace := obj[&quot;namespace&quot;]:
     if (namespace&lt;&gt;&quot;&quot;) then
           tmp := cat(&quot;using namespace &quot;, namespace<Font encoding="UTF-8">, &quot;;\134n&quot;): </Font><Font style="Text">namepsace include</Font>
           if ( StringTools[Search](tmp,_maverick_ext_obj_namespace_strs)&lt;1 ) then
                 _maverick_ext_obj_namespace_strs := cat(_maverick_ext_obj_namespace_strs, tmp):
           end:
     end if:
     if (namespace&lt;&gt;&quot;&quot;) then
         _maverick_ext_obj_def_strs := cat(_maverick_ext_obj_def_strs,  __tabs, __tabs, &quot;std::unique_ptr&lt;&quot;,namespace,&quot;::&quot;,objType, &quot;&gt; &quot;, objCName<Font encoding="UTF-8">, &quot; = nullptr;\134n&quot;):
</Font>     else
         _maverick_ext_obj_def_strs := cat(_maverick_ext_obj_def_strs,  __tabs, __tabs, &quot;std::unique_ptr&lt;&quot;,objType, &quot;&gt; &quot;, objCName<Font encoding="UTF-8">, &quot; = nullptr;\134n&quot;):
</Font>     end:
    _maverick_ext_obj_setup_str := cat(_maverick_ext_obj_setup_str,
                                                       __tabs, objCName, &quot; = std::unique_ptr&lt;&quot;,objType, &quot;&gt; ( new &quot;, objType<Font encoding="UTF-8">, &quot;(\134&quot;&quot;, </Font>objCommonName<Font encoding="UTF-8">,&quot;\134&quot;));\134n&quot;,</Font>
                                                       __tabs,<Font encoding="UTF-8">&quot;try {\134n&quot;,
</Font>                                                       __tabs,__tabs, &quot;<Font encoding="UTF-8">gc_function = &amp;( (*gc_mapped_objects)(\134&quot;&quot;,</Font>convert(objCommonName,string)<Font encoding="UTF-8">,&quot;\134&quot;) );\134n&quot;,</Font>
                                                       __tabs, &quot;<Font encoding="UTF-8">} catch (...) {\134n&quot;,
</Font>                                                       __tabs, __tabs, &quot;<Font encoding="UTF-8">throw std::runtime_error(\134&quot;Cannot find mapped object named '&quot;, </Font>convert(objCommonName,string) <Font encoding="UTF-8">,&quot;' in the lua data file\134\134n\134&quot;);\134n</Font>&quot;,
<Font encoding="UTF-8">                                                       __tabs, &quot;}\134n&quot;,</Font>
                                                       __tabs, objCName<Font encoding="UTF-8">, &quot;-&gt;setup(*gc_function);\134n\134n&quot;
</Font>                                                       );

    _maverick_ext_obj_print_str := cat(_maverick_ext_obj_print_str, 
<Font encoding="UTF-8">                                       __tabs, &quot;out &lt;&lt; \134&quot;\134\134n\134&quot;;\134n&quot;,</Font>
                                       __tabs, <Font encoding="UTF-8">objCName, &quot;-&gt;printInfo(out, info_level);\134n&quot;);</Font>

    <Font style="Text">Include the header if required</Font>
<Font encoding="UTF-8">    tmp := cat(&quot;#include \134&quot;&quot;, </Font>obj[&quot;include&quot;]<Font encoding="UTF-8">, &quot;\134&quot;\134n&quot;): </Font><Font style="Text">namepsace include</Font>
    if ( StringTools[Search](tmp,_maverick_ext_obj_includes_str)&lt;1 ) then
          _maverick_ext_obj_includes_str := cat(_maverick_ext_obj_includes_str, tmp):
    end:

    <Font style="Text">Loop over the number of declared functions for this object</Font>
    functions := obj[&quot;functions&quot;]:
    for i_func from 1 to nops(functions) do
          <Font style="Text">number of arguments taken from this function</Font>
          num_args := nops(lhs( functions[i_func] )):
          func_name :=  op(0,lhs( functions[i_func] )):
          ext_func_name :=  op(0,rhs( functions[i_func] )):

          _ext_object_language_defs := [op(_ext_object_language_defs), [ func_name, num_args, ext_func_name, objCName ] ]:
          <Font style="Text">loop over the number of arguments</Font>
          for i_arg from 1 to num_args do
               _ext_obj_convert := [op(_ext_obj_convert), (D[i_arg](func_name))=cat(func_name ,_D_,i_arg)]:
               _ext_object_language_defs := [op(_ext_object_language_defs), [ cat(func_name ,_D_,i_arg), num_args, cat(ext_func_name ,_D_,i_arg) , objCName ] ]:
               for i_second_arg from (i_arg) to num_args do
                        _ext_obj_convert := [op(_ext_obj_convert), (D[i_arg,i_second_arg](func_name))=cat(func_name ,_D_,i_arg,_,i_second_arg)]:
                        _ext_object_language_defs := [op(_ext_object_language_defs), [ cat(func_name ,_D_,i_arg,_D_,i_second_arg), num_args, cat(ext_func_name ,_D_,i_arg,_D_,i_second_arg) , objCName ] ]:
               end do: <Font style="Text">end do second argument</Font>
          end do: <Font style="Text">end do i_arg</Font>
          
    end do:  <Font style="Text">end do i_func</Font>
end: <Font style="Text">end if header&lt;&gt;main_func</Font>
end: <Font style="Text">end main for</Font>

<Font style="Text">add the first part
</Font>first_part := cat( <Font encoding="UTF-8">&quot;    GC::GenericContainer const * gc_mapped_objects = nullptr;\134n&quot;,</Font><Font style="Text">
</Font><Font encoding="UTF-8">                        &quot;    try {\134n&quot;,
                        &quot;        gc_mapped_objects = &amp;gc(\134&quot;MappedObjects\134&quot;);\134n&quot;,
                        &quot;    } catch (...) {\134n&quot;,
                        &quot;        throw std::runtime_error(\134&quot;Cannot find 'MappedObjects' inside 'Model' in the lua data file\134\134n\134&quot;);\134n&quot;,
                        &quot;    }\134n&quot;,
                        &quot;    GC::GenericContainer const * gc_function = nullptr;\134n\134n&quot;
</Font>                        );<Font style="Text">
</Font>if (_maverick_ext_obj_setup_str &lt;&gt; &quot;&quot;) then
    _maverick_ext_obj_setup_str := cat(first_part ,_maverick_ext_obj_setup_str):
end:

if (_maverick_ext_obj_print_str &lt;&gt; &quot;&quot;) then
    _maverick_ext_obj_print_str<Font encoding="UTF-8"> := cat(_maverick_ext_obj_print_str, __tabs, &quot;out &lt;&lt; \134&quot;\134\134n\134&quot;;&quot;</Font>):
end:
0;   
end: <Font style="Text">end procedure
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">procedure to add declaration to unknown C variables</Font>
addVariableDeclaration := proc(code_sequence::Array, var_type::string, returnname::string)
local known_var_numbers, i, tmp, output:

    output := code_sequence;

    known_var_numbers := Array([]): 
         
    for i from 1 to ArrayTools[NumElems](output) do
         tmp := StringTools[Split](output[i], &quot;=&quot;); <Font style="Text">split the string in lhs and rhs</Font>
         tmp := tmp[1]: <Font style="Text">get lhs</Font>
         if ((StringTools[Search](returnname,tmp)&lt;1) and <Font style="Text">if the variable name does not contain the return type</Font>
             (StringTools[Search](&quot;t&quot;,tmp)&gt;0) ) <Font style="Text">if it contains t
</Font>             then  <Font style="Text">in this case, the lhs is of the type: 'txxx '</Font>
                   tmp := substring(tmp,2..-2):
                   if not(has(known_var_numbers,tmp))  then  <Font style="Text">in this case, it is a new variable</Font>
                       ArrayTools[Append](known_var_numbers, tmp):
                       output[i] := cat(var_type, &quot; &quot;, output[i]);
                   end if:
         end if: 
    end do:

   output;
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">convertParamsAndFunctions := proc(expr)
    <Font style="Text">Substitute model parameters and derivatives</Font>
    subs( _ext_obj_convert,  subs(__model_params_convert, convert(expr,D)) ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">generateCode := proc(expr, returnname::string) _generateCode(expr, returnname): end:
_generateCode := proc(expr, returnname::string)
local tmp, i, output, code_sequence:
    if (returnname=&quot;zeta&quot;) then error(&quot;Return name must be different from zeta&quot;): end: <Font style="Text">check the return name</Font>

    <Font style="Text">Substitute model parameters and derivatives
    </Font>tmp := convertParamsAndFunctions(expr):<Font style="Text">

</Font>#if (returnname=&quot;asantesana&quot;) then __debug[2]:=tmp: error(&quot;aaa&quot;): end:
    <Font style="Text">Generate code</Font>
    #code_sequence := CodeGeneration[C](convert(tmp,list), optimize=true, resultname=returnname, functionprecision=double, precision=double, output=string ) ; #defaulttype=double, 
    code_sequence := CodeGeneration[Translate](convert(tmp,list), language=&quot;maverick_language&quot;, optimize=true, resultname=returnname, functionprecision=double, precision=double, output=string ) ;

    <Font style="Text">TO FIX: this should not be necessary if the code generation would be correct</Font>
    code_sequence := StringTools[SubstituteAll](code_sequence,  &quot;(int)&quot;, &quot;&quot;);
    code_sequence := StringTools[SubstituteAll](code_sequence,  &quot;(double)&quot;, &quot;&quot;);

    code_sequence := StringTools[Split] (code_sequence<Font encoding="UTF-8">, &quot;\134n&quot;);
</Font>
    if (nops(code_sequence)&gt;1) then code_sequence := code_sequence[1..-2]: end: <Font style="Text">remove last empty string</Font>

    code_sequence := addVariableDeclaration(convert(code_sequence,Array), &quot;real&quot;, returnname);

    output := &quot;&quot;:

    for i from 1 to (ArrayTools[NumElems](code_sequence)) do
        output := cat(output, __tabs, <Font encoding="UTF-8">code_sequence[i], &quot;\134n&quot;);</Font>
    end do:

    output:
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">initLanguageModule := proc()

 <Font style="Text">module of language translation</Font>
maverick_language_module := proc() module()
    local i_func, tmp, i_a:

    export PrintTarget, Printer;

    PrintTarget := proc() Printer:-PrintTarget(args); end proc:
    Printer := eval(CodeGeneration[LanguageDefinition][Get](&quot;C&quot;)):-Printer;

    for i_func from 1 to nops(_ext_object_language_defs) do
          tmp := []:
          for i_a from 1 to _ext_object_language_defs[i_func][2] do
               tmp := [op(tmp), numeric]:
          end do:
          Printer:-AddFunction( convert(_ext_object_language_defs[i_func][1],string), tmp::numeric,  cat(convert(_ext_object_language_defs[i_func][4],string),&quot;-&gt;&quot;,convert(_ext_object_language_defs[i_func][3],string) ) );
          
    end do:

    #Printer:-AddFunction(&quot;sin&quot;, [anything]::anything, &quot;Sisdne&quot;);
    #Printer:-AddOperator(CodeGeneration[Names]:-Assignment = &quot;:=&quot;);
end module: end proc:

end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">generateOcpCode := proc(problem_name::string, output_directory::string)
   _class_name := problem_name:
   
   clearCode():

   writeline(default,&quot;Processing mapped objects...&quot;);
   processMappedObjects():

   writeline(default,&quot;Code generation starts...&quot;);
   initLanguageModule():
   CodeGeneration[LanguageDefinition][Add](&quot;maverick_language&quot;,maverick_language_module);

   writeline(default,&quot;Loading templates...&quot;);
   loadTemplates():
   
   writeFirst();

   <Font style="Text">writing parameters</Font>
   writeline(default, &quot;Generating parameters...&quot; );
   writeParameters():
   <Font style="Text">fill constructor
   </Font>writeline(default, &quot;Generating class constructor...&quot;);<Font style="Text">
   </Font>MaverickCodegenConstructor:-fillConstructor();
   <Font style="Text">fill bounds
</Font>   writeline(default, &quot;Generating OCP bounds...&quot;):<Font style="Text">
</Font>   MaverickCodegenBounds:-fillBounds():
   <Font style="Text">write guess</Font>
   writeline(default,&quot;Generating guess...&quot;);
   writeGuess():
   <Font style="Text">write target
</Font>   writeline(default, &quot;Generating target...&quot;);
   MaverickCodegenTarget:-writeTarget():
   <Font style="Text">write fo eqns
   </Font>writeline(default, &quot;Generating first order equations...&quot;);<Font style="Text">
</Font>   MaverickCodegenFoEqns:-writeFoEqns():
   <Font style="Text">write constraints
   </Font>writeline(default, &quot;Generating constraints...&quot;);<Font style="Text">
</Font>   MaverickCodegenConstraints:-writeConstraints():
   <Font style="Text">write bcs and event constraints
   </Font>writeline(default, &quot;Generating boundary conditions and event constraints...&quot;);<Font style="Text">
</Font>   MaverickCodegenBcs:-writeBcsAndEventConstraints():
   <Font style="Text">write post processing
   </Font>writeline(default, &quot;Generating post processing...&quot;);<Font style="Text">
</Font>   MaverickCodegenPostProc:-writePostProcessing():
   <Font style="Text">write main
</Font>   writeline(default, &quot;Generating main file...&quot;);
   writeMain():
   <Font style="Text">write library
</Font>   writeline(default, &quot;Generating library files...&quot;);
   writeLibrary():
   <Font style="Text">write compile.sh
</Font>   writeline(default, &quot;Generating compile file...&quot;);
   writeCompile():
   <Font style="Text">write final files</Font>   
   writeline(default, &quot;Writing source files...&quot;);
   writeSourceFiles(problem_name, output_directory);

end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeFirst := proc()
   <Font style="Text">write class name</Font>
   replaceAllInTemplateHH(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;, _class_name ): 
   replaceAllInTemplateCC(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;, _class_name ):

   <Font style="Text">write number of phases
</Font>   replaceInTemplateCC(&quot;_MAVERICK_ENTER_NUM_PHASES&quot;, convert(__num_phases,string) );
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeGuess := proc()
local ocp_guess_mesh_dependent, ocp_guess_mesh_independent, guess, P, i, tmp, tmp_code, guess_hh_str, guess_cc_str, should_write_guess, guess_code_at_mesh, guess_code_at_mesh_alg, guess_code, states, controls, algebraic_states, algebraic_controls, ocp_guess_mesh_dependent_alg:

   should_write_guess := false:
   for P from 1 to __num_phases do

      ocp_guess_mesh_dependent := []:
      ocp_guess_mesh_dependent_alg := []:
      ocp_guess_mesh_independent := []:

      guess := __OCP[P][&quot;guess&quot;]:
      states := __OCP[P][&quot;states&quot;]:
      controls := __OCP[P][&quot;controls&quot;]:
      algebraic_states := __OCP[P][&quot;algebraic_states&quot;]:
      algebraic_controls := __OCP[P][&quot;algebraic_controls&quot;]:

      for i from 1 to nops(guess) do 
        tmp := lhs(guess[i]):
        if ( has(states, tmp) or has(controls, tmp) ) then
            ocp_guess_mesh_dependent := [op(ocp_guess_mesh_dependent), guess[i]]:
        elif ( has(algebraic_states, tmp) or has(algebraic_controls, tmp) ) then
            ocp_guess_mesh_dependent_alg := [op(ocp_guess_mesh_dependent_alg), guess[i]]:
        else
            ocp_guess_mesh_independent := [op(ocp_guess_mesh_independent), guess[i]]:            
        end:

      end do:
      
      guess_cc_str := &quot;&quot;:

      if (nops(guess)&gt;0) then
         should_write_guess := true:
         tmp := ocp2nlp(P, ocp_guess_mesh_dependent):
         guess_code_at_mesh[P] := _generateCode(tmp,&quot;states_controls&quot;);

         tmp := ocp2nlp(P, ocp_guess_mesh_dependent_alg):
         guess_code_at_mesh_alg[P] := _generateCode(tmp,&quot;algebraic_states_controls&quot;);
    
         tmp := ocp2nlp(P, ocp_guess_mesh_independent):
         guess_code[P] := generateCode(tmp, &quot;parameters&quot;);
         
      else
         guess_code[P] := &quot;&quot;:
         guess_code_at_mesh[P] := &quot;&quot;:
         guess_code_at_mesh_alg[P] := &quot;&quot;:
      end if:

    end do: <Font style="Text">loop phases</Font>
    
    if (should_write_guess) then
        replaceAllInGuessTemplateHH(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;,_class_name):
        guess_hh_str := &quot;&quot;:
        for i from 1 to ArrayTools[NumElems](__output_guess_array_hh) do
             guess_hh_str := cat(guess_hh_str, __output_guess_array_hh[i], <Font encoding="UTF-8">&quot;\134n&quot;</Font>):
        end do:

        replaceInTemplateHH(&quot;_MAVERICK_ENTER_GUESS&quot;,guess_hh_str):

        replaceAllInGuessTemplateCC(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;,_class_name):
        replaceInGuessTemplateCC(&quot;_MAVERICK_ENTER_GUESS_EVAL_BODY&quot;,getCodeForPhases(guess_code) ):
        replaceInGuessTemplateCC(&quot;_MAVERICK_ENTER_GUESS_EVAL_AT_MESH_BODY&quot;,getCodeForPhases(guess_code_at_mesh)):
        replaceInGuessTemplateCC(&quot;_MAVERICK_ENTER_GUESS_EVAL_AT_MESH_ALGEBRAIC_BODY&quot;,getCodeForPhases(guess_code_at_mesh_alg)):

        for i from 1 to ArrayTools[NumElems](__output_guess_array_cc) do
             guess_cc_str := cat(guess_cc_str, <Font encoding="UTF-8">__output_guess_array_cc[i], &quot;\134n&quot;):
</Font>        end do:
        replaceInTemplateCC(&quot;_MAVERICK_ENTER_GUESS&quot;,guess_cc_str):
    else 
        replaceInTemplateHH(&quot;_MAVERICK_ENTER_GUESS&quot;,&quot;&quot;):
        replaceInTemplateCC(&quot;_MAVERICK_ENTER_GUESS&quot;,&quot;&quot;):
    end if:
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeParameters := proc()
   replaceAllInTemplateHH(&quot;_MAVERICK_ENTER_NUM_MODEL_PARAMS&quot;, convert(__num_model_params,string) ):
   replaceAllInTemplateCC(&quot;_MAVERICK_ENTER_PARAMS_NAMES&quot;, __model_params_names_str ):
   replaceAllInTemplateHH(&quot;_MAVERICK_ENTER_PARAMS_INDEX_DEFINES&quot;, __model_params_index_defines ):
   replaceInTemplateHH(&quot;_MAVERICK_ENTER_EXT_OBJ_INCLUDES&quot;, _maverick_ext_obj_includes_str):
   #replaceInTemplateHH(&quot;_MAVERICK_ENTER_EXT_OBJECTS_NAMESPACE&quot;, _maverick_ext_obj_namespace_strs):
   replaceInTemplateCC(&quot;_MAVERICK_ENTER_EXT_OBJECTS_NAMESPACE&quot;, _maverick_ext_obj_namespace_strs):
   replaceInTemplateHH(&quot;_MAVERICK_ENTER_EXT_OBJECTS_DEFINITIONS&quot;, _maverick_ext_obj_def_strs):
   replaceInTemplateCC(&quot;_MAVERICK_ENTER_EXT_OBJECTS_SETUP&quot;, _maverick_ext_obj_setup_str):
   replaceInTemplateCC(&quot;_MAVERICK_ENTER_DERIVED_INFO&quot;, _maverick_ext_obj_print_str):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeMain := proc()
   replaceAllInArray(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;, _class_name, __output_array_main_cc ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeLibrary := proc()
   replaceAllInArray(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;, _class_name, __output_array_lib_cc ):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeCompile := proc()
   replaceAllInArray(&quot;_MAVERICK_ENTER_CLASS_NAME&quot;, _class_name, __output_array_compile ):
end:

</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeSourceFiles := proc(files_name::string, output_directory::string)
local filename, fid, i, out_dir:
    out_dir := output_directory:
    if (out_dir=&quot;&quot;) then out_dir:=&quot;.&quot;: end:
    if (out_dir[-1]&lt;&gt;&quot;/&quot;) then out_dir := cat(out_dir, &quot;/&quot;): end:

    <Font style="Text">.cc file</Font>
    filename := cat(out_dir, files_name, &quot;.cc&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_cc) do
        fprintf(fid,__output_array_cc[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):

    <Font style="Text">.hh file</Font>
    filename := cat(out_dir, files_name, &quot;.hh&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_hh) do
        fprintf(fid,__output_array_hh[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):

   <Font style="Text"> main .cc file</Font>
    filename := cat(out_dir, &quot;/&quot;, files_name, &quot;_main.cc&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_main_cc) do
        fprintf(fid,__output_array_main_cc[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):

<Font style="Text">    library .hh file</Font>
    filename := cat(out_dir, &quot;/&quot;, files_name, &quot;_lib.h&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_lib_hh) do
        fprintf(fid,__output_array_lib_hh[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):

<Font style="Text">    library .cc file</Font>
    filename := cat(out_dir, &quot;/&quot;, files_name, &quot;_lib.cc&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_lib_cc) do
        fprintf(fid,__output_array_lib_cc[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):
<Font style="Text">    compile file</Font>
    filename := cat(out_dir, &quot;/compile.sh&quot;);
    fid := fopen(filename, WRITE):
    for i from 1 to ArrayTools[NumElems](__output_array_compile) do
        fprintf(fid,__output_array_compile[i]);
        <Font encoding="UTF-8">fprintf(fid,&quot;\134n&quot;);</Font>
    end do:
    fclose(fid):
    ssystem(cat(&quot;chmod +x &quot;,filename)):
end: <Font style="Text">write source files</Font>
</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">end: <Font style="Text">end module</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib( 'MaverickCodegen' );</Text-field>
</Input>
</Group>
</Section>
<Section collapsed="false" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Maverick interface module</Text-field></Title>
<Group hide-output="false" labelreference="L502" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">Maverick := module()</Text-field><Text-field style="Normal" layout="Normal"> <Font style="Maple Input">    description &quot;Code generation package for Maverick Optimal Control software&quot;;
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">#uses MaverickCodegen;</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">Module options</Font>
option package,   <Font style="Text">all exported names are automatically protected</Font>
          load = init; <Font style="Text">this procedure is invoked when loading the module


</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">global __mapped_maverick_objects, __mapped_objects, __num_phases, __OCP, __NLP,__model_params,
         __model_params_names_str, __model_params_index_defines, __model_params_convert, __num_model_params, 
         __states_controls, __state_control_derivatives, __algebraic_states_controls, __parameters, __initial_state_control, __final_state_control,
         __tabs, __debug:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">local  state_control, state_control_derivative, algebraic_state_control, parameters, initial_state_control, final_state_control,
       
      __phase_declared,
      __has_init,

      <Font style="Text">procedures</Font>
      clear, createConversion, ocp2nlp, init, prepareForPhases,setupParameters,
      _mapFunctionToCustomObject,
      _mapFunctionToMaverickObject,
      _generateCode,
      _setPhase,
      check_has_init,
      containsOneArrayElem,
      containsExactlyOneArrayElem:

</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">export NewOcpProblem,
       GenerateCode,
       SetPhase,
       MapFunctionToCustomObject,
       MapFunctionToMaverickObject:<Font style="Text">

</Font></Text-field><Text-field style="Text" layout="Normal">@===================================================================@</Text-field><Text-field style="Text" layout="Normal">#                             _           _                         #</Text-field><Text-field style="Text" layout="Normal">#   _____  ___ __   ___  _ __| |_ ___  __| |  _ __  _ __ ___   ___  #</Text-field><Text-field style="Text" layout="Normal"><Font encoding="UTF-8">#  / _ \134 \134/ / '_ \134 / _ \134| '__| __/ _ \134/ _` | | '_ \134| '__/ _ \134 / __| #</Font></Text-field><Text-field style="Text" layout="Normal"># |  __/&gt;  &lt;| |_) | (_) | |  | ||  __/ (_| | | |_) | | | (_) | (__  #</Text-field><Text-field style="Text" layout="Normal"><Font encoding="UTF-8">#  \134___/_/\134_\134 .__/ \134___/|_|   \134__\134___|\134__,_| | .__/|_|  \134___/ \134___| #</Font></Text-field><Text-field style="Text" layout="Normal">#           |_|                              |_|                    #</Text-field><Text-field style="Text" layout="Normal">@===================================================================@</Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">NewOcpProblem := proc( num_p::integer )
    if (num_p&lt;1) then
        error(&quot;Number of phases must be greater than zero&quot;):
    end:
    __num_phases := num_p:
    clear():
    prepareForPhases():
    __num_phases:
    __has_init := 1199;
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">SetPhase := proc( {phase::integer:=0, 
                   states::list([scalar,scalar..scalar]):=[], 
                   controls::list([scalar,scalar..scalar]):=[],
                   algebraic_states::list([scalar,scalar..scalar]):=[], 
                   algebraic_controls::list([scalar,scalar..scalar]):=[], 
                   parameters::list([symbol,scalar..scalar]):=[], 
                   lagrange_target::algebraic := 0, 
                   mayer_target::algebraic := 0,
                   first_order_equations::list:=[], 
                   point_constraints::list([algebraic,scalar..scalar,string]) := [], 
                   path_constraints::list([algebraic,scalar..scalar,string]) := [],
                   integral_constraints::list([algebraic,scalar..scalar,string]) := [], 
                   boundary_conditions::list([algebraic,scalar..scalar,string]) := [],
                   event_constraints::list([algebraic,scalar..scalar,string]) := [],
                   post_processing::list([algebraic,string]) := [],
                   differential_post_processing::list([algebraic,string]) := [],
                   integral_post_processing::list([algebraic,string]) := [],
                   guess::list := []}
                 )
      local tmp, tmp_vars, tmp_vars_nab, P, i, j, tmp_state_list, tmp_control_list, tmp_algebraic_state_list, tmp_algebraic_control_list, tmp_state_control_der_list, tmp_param_list, tmp_array;

      P := phase:

      check_has_init(true):

      <Font style="Text">Consistency check</Font>
      if (P&lt;1) then error(&quot;Phase index must be greater than zero&quot;): end:
      if (P&gt;__num_phases) then error(cat(&quot;Number of phase is greater than the OCP number of phases &quot;, convert(__num_phases,string))): end:

      if ((nops(states) =0) and (nops(algebraic_states)=0)) then error(&quot;No states have been declared&quot;): end:
      if ((nops(controls) =0) and (nops(algebraic_controls)=0) ) then error(&quot;No controls have been declared&quot;): end:
      if ( (nops(states)+nops(algebraic_states) )&lt;&gt; nops(first_order_equations)) then error(&quot;Number of states and algebraic states must equal number of first order equations&quot;): end:
      if (nops(event_constraints)&gt;0) and (P=__num_phases) then error(&quot;Event constraints cannot be declared for the last phase&quot;); end:

      if (__phase_declared[P]=true) then WARNING(&quot;Phase already set. It will be overwritten&quot;): end:
      if ( (not(has(lagrange_target,zeta))) and (not(has(mayer_target,zeta_i))) and (not(has(mayer_target,zeta_f))) ) then WARNING(&quot;Target does not depend on zeta!!&quot;): end:
      if (nops(guess)=0) then WARNING(&quot;No guess have been provided. Zero guess will be used&quot;); end:
      if (nops(boundary_conditions)=0) then WARNING(&quot;No boundary conditions are declared&quot;); end:
      if (nops(event_constraints)=0) and (P&lt;__num_phases) then WARNING(&quot;No event constraints are declared&quot;); end:

      <Font style="Text">Check zeta dependecies</Font>
      tmp_state_control_der_list := Array(1..nops(states) + nops(controls) ):

      tmp_state_list := Array(1..nops(states)): tmp_control_list := Array(1..nops(controls)): tmp_algebraic_state_list := Array(1..nops(algebraic_states)): tmp_algebraic_control_list := Array(1..nops(algebraic_controls)): tmp_param_list := Array(1..nops(parameters)):
      for i from 1 to nops(states) do
          tmp := states[i]:
          tmp_state_list[i] := tmp[1]:
          if not(has(tmp[1],zeta)) then error(cat(&quot;state &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; is not a function of zeta&quot;) ): end:
          tmp_state_control_der_list[i] := diff(tmp_state_list[i], zeta):
      end:
      for i from 1 to nops(controls) do
          tmp := controls[i]:
          tmp_control_list[i] := tmp[1]:
          if not(has(tmp[1],zeta)) then error(cat(&quot;control &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; is not a function of zeta&quot;) ): end:
          tmp_state_control_der_list[nops(states)+i] := diff(tmp_control_list[i], zeta):
      end:
      for i from 1 to nops(algebraic_states) do
          tmp := algebraic_states[i]:
          tmp_algebraic_state_list[i] := tmp[1]:
          if not(has(tmp[1],zeta)) then error(cat(&quot;algebraic state &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; is not a function of zeta&quot;) ): end:
      end:
      for i from 1 to nops(algebraic_controls) do
          tmp := algebraic_controls[i]:
          tmp_algebraic_control_list[i] := tmp[1]:
          if not(has(tmp[1],zeta)) then error(cat(&quot;algebraic control &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; is not a function of zeta&quot;) ): end:
      end:
      for i from 1 to nops(parameters) do
          tmp := parameters[i]:
          tmp_param_list[i] := tmp[1]:
          if (has(tmp[1],zeta)) then error(cat(&quot;parameter &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; is a function of zeta&quot;) ): end:
      end:

       <Font style="Text">check bounds dependecies</Font>
      tmp_array := ArrayTools[Concatenate](2,tmp_state_list,tmp_control_list,tmp_algebraic_state_list,tmp_algebraic_control_list,tmp_param_list):
      for i from 1 to nops(states) do
          tmp := states[i]:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for state &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:
      for i from 1 to nops(controls) do
          tmp := controls[i]:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for control &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:
      for i from 1 to nops(algebraic_states) do
          tmp := algebraic_states[i]:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for algebraic state &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:
      for i from 1 to nops(algebraic_controls) do
          tmp := algebraic_controls[i]:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for algebraic control &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:
      for i from 1 to nops(parameters) do
          tmp := parameters[i]:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for parameter &quot;,convert(tmp[1],string),&quot; at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:

      <Font style="Text">check fo equations</Font>
      for i from 1 to nops(first_order_equations) do
          tmp := first_order_equations[i]:
          for j from 1 to nops(algebraic_states) do
              if (has(tmp[1],diff(algebraic_states[j][1],zeta))) then error(cat(&quot;first order equation at index &quot;,convert(i,string),&quot; contains algebraic state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if (has(tmp[1],diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;first order equation at index &quot;,convert(i,string),&quot; contains algebraic control derivatives&quot;) ): end:
          end:
      end:

      <Font style="Text">check path constraints</Font>
      for i from 1 to nops(path_constraints) do
          tmp := first_order_equations[i]:
          for j from 1 to nops(algebraic_states) do
              if (has(tmp[1],diff(algebraic_states[j][1],zeta))) then error(cat(&quot;path constraint at index &quot;,convert(i,string),&quot; contains algebraic state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if (has(tmp[1],diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;path constraint at index &quot;,convert(i,string),&quot; contains algebraic control derivatives&quot;) ): end:
          end:
      end:

      <Font style="Text">check target
       </Font>tmp := lagrange_target:
          for j from 1 to nops(algebraic_states) do
              if (has(tmp,diff(algebraic_states[j][1],zeta))) then error(cat(&quot;lagrange target contains algebraic state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if (has(tmp,diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;lagrange target contains algebraic control derivatives&quot;) ): end:
          end:

<Font style="Text">       </Font>tmp := mayer_target:
      for j from 1 to nops(algebraic_states) do
              if ( (has(tmp,algebraic_states[j][1])) or (has(tmp[1],diff(algebraic_states[j][1],zeta))) ) then error(cat(&quot;mayer target contains algebraic states or their derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if ((has(tmp,algebraic_controls[j][1])) or (has(tmp[1],diff(algebraic_controls[j][1],zeta))) ) then error(cat(&quot;mayer target contains algebraic controls or their derivatives&quot;) ): end:
          end:

      <Font style="Text">check constraints</Font>
      for i from 1 to nops(point_constraints) do
          tmp := point_constraints[i]:
          for j from 1 to nops(states) do
              if (has(tmp[1],diff(states[j][1],zeta))) then error(cat(&quot;point constraint at index &quot;,convert(i,string),&quot; contains state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(controls) do
              if (has(tmp[1],diff(controls[j][1],zeta))) then error(cat(&quot;point constraint at index &quot;,convert(i,string),&quot; contains control derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_states) do
              if ( (has(tmp[1],algebraic_states[j][1])) or (has(tmp[1],diff(algebraic_states[j][1],zeta))) ) then error(cat(&quot;point constraint at index &quot;,convert(i,string),&quot; contains algebraic states or their derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if ((has(tmp[1],algebraic_controls[j][1])) or (has(tmp[1],diff(algebraic_controls[j][1],zeta))) ) then error(cat(&quot;point constraint at index &quot;,convert(i,string),&quot; contains algebraic controls or their derivatives&quot;) ): end:
          end:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for point constraint at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:

      for i from 1 to nops(path_constraints) do
          tmp := path_constraints[i]:
          for j from 1 to nops(algebraic_states) do
              if (has(tmp[1],diff(algebraic_states[j][1],zeta))) then error(cat(&quot;path constraint at index &quot;,convert(i,string),&quot; contains algebraic state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if (has(tmp[1],diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;path constraint at index &quot;,convert(i,string),&quot; contains algebraic control derivatives&quot;) ): end:
          end:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for path constraint at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:

      for i from 1 to nops(integral_constraints) do
          tmp := integral_constraints[i]:
          for j from 1 to nops(algebraic_states) do
              if (has(tmp[1],diff(algebraic_states[j][1],zeta))) then error(cat(&quot;integral constraint at index &quot;,convert(i,string),&quot; contains algebraic state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if (has(tmp[1],diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;integral constraint at index &quot;,convert(i,string),&quot; contains algebraic control derivatives&quot;) ): end:
          end:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for integral constraint at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
          if ( has(op(1,tmp[2]), zeta) or has(op(2,tmp[2]), zeta) ) then error(cat(&quot;bounds for integral constraint at index &quot;,convert(i,string),&quot; depend on zeta&quot;) ): end:
      end:

      for i from 1 to nops(boundary_conditions) do
          tmp := boundary_conditions[i]:
          if has(tmp[1],zeta) then error(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; depends on zeta&quot;) ): end:
          if ( not(has(tmp[1],zeta_i)) and not(has(tmp[1],zeta_f)) ) then WARNING(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; does not depend on zeta_i neither on zeta_f&quot;) ): end:
          for j from 1 to nops(states) do
              if (has(tmp[1],diff(states[j][1],zeta))) then error(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; contains state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(controls) do
              if (has(tmp[1],diff(controls[j][1],zeta))) then error(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; contains control derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_states) do
              if ( (has(tmp[1],algebraic_states[j][1])) or (has(tmp[1],diff(algebraic_states[j][1],zeta))) ) then error(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; contains algebraic states or their derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if ((has(tmp[1],algebraic_controls[j][1])) or (has(tmp[1],diff(algebraic_controls[j][1],zeta))) ) then error(cat(&quot;boundary condition at index &quot;,convert(i,string),&quot; contains algebraic controls or their derivatives&quot;) ): end:
          end:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for boundary condition at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
          if ( has(op(1,tmp[2]), zeta) or has(op(2,tmp[2]), zeta) ) then error(cat(&quot;bounds for boundary condition at index &quot;,convert(i,string),&quot; depend on zeta&quot;) ): end:
      end:

      for i from 1 to nops(event_constraints) do
          tmp := event_constraints[i]:
          for j from 1 to nops(states) do
              if (has(tmp[1],diff(states[j][1],zeta))) then error(cat(&quot;event constraint at index &quot;,convert(i,string),&quot; contains state derivatives&quot;) ): end:
          end:
          for j from 1 to nops(controls) do
              if (has(tmp[1],diff(controls[j][1],zeta))) then error(cat(&quot;event constraint at index &quot;,convert(i,string),&quot; contains control derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_states) do
              if ( (has(tmp[1],algebraic_states[j][1])) or (has(tmp[1],diff(algebraic_states[j][1],zeta))) ) then error(cat(&quot;event constraint at index &quot;,convert(i,string),&quot; contains algebraic states or their derivatives&quot;) ): end:
          end:
          for j from 1 to nops(algebraic_controls) do
              if ((has(tmp[1],algebraic_controls[j][1])) or (has(tmp[1],diff(algebraic_controls[j][1],zeta))) ) then error(cat(&quot;evant constraint at index &quot;,convert(i,string),&quot; contains algebraic controls or their derivatives&quot;) ): end:
          end:
          if ( containsOneArrayElem(op(1,tmp[2]), tmp_array) or containsOneArrayElem(op(2,tmp[2]), tmp_array) ) then error(cat(&quot;bounds for event constraint at index &quot;,convert(i,string),&quot; depend on OCP states, controls or parameters&quot;) ): end:
      end:

     <Font style="Text">check guess
</Font>     for i from 1 to nops(guess) do
         tmp := guess[i]:
         <Font style="Text">check is an equation</Font>
         if not(type(tmp,equation)) then error(cat(&quot;Guess at index &quot;, convert(i,string), &quot; is not an equation of the form: 'state/control/parameter = something'&quot;)); end:

         <Font style="Text">check lhs</Font>
         if not( containsExactlyOneArrayElem(lhs(tmp), tmp_state_list) or containsExactlyOneArrayElem(lhs(tmp), tmp_algebraic_state_list) or containsExactlyOneArrayElem(lhs(tmp), tmp_control_list) or containsExactlyOneArrayElem(lhs(tmp), tmp_algebraic_control_list) or containsExactlyOneArrayElem(lhs(tmp), tmp_param_list) ) then 
             error(cat(&quot;Left hand side of guess at index &quot;, convert(i,string), &quot; is not a state, control or parameter&quot;)); 
         end:

         <Font style="Text">check rhs</Font>
         if ( containsExactlyOneArrayElem(rhs(tmp), tmp_state_list) or containsExactlyOneArrayElem(rhs(tmp), tmp_algebraic_state_list) or containsExactlyOneArrayElem(rhs(tmp), tmp_control_list) or containsExactlyOneArrayElem(rhs(tmp), tmp_algebraic_control_list) or containsExactlyOneArrayElem(rhs(tmp), tmp_param_list) ) then 
             error(cat(&quot;Right hand side of guess at index &quot;, convert(i,string), &quot; contains a state, control or parameter&quot;)); 
         end:

         <Font style="Text">check algebraic vars</Font>
         for j from 1 to nops(algebraic_states) do
              if (has(tmp,diff(algebraic_states[j][1],zeta))) then error(cat(&quot;guess contains algebraic state derivatives&quot;) ): end:
          end:
         for j from 1 to nops(algebraic_controls) do
              if (has(tmp,diff(algebraic_controls[j][1],zeta))) then error(cat(&quot;guess contains algebraic control derivatives&quot;) ): end:
         end:

     end do: <Font style="Text">end guess</Font>
     <Font style="Text">check post processing
</Font>     for i from 1 to nops(post_processing) do<Font style="Text">
         </Font>tmp := post_processing[i]:<Font style="Text">

         check they do not contain differential states
         </Font>if ( containsOneArrayElem( tmp[1], tmp_state_control_der_list )<Font style="Text"> </Font>) then<Font style="Text">
            </Font><Font encoding="UTF-8">error(cat(&quot;Post processing at index &quot;, convert(i,string), &quot; contains a state or control derivative. Use \134'differential_post_processing instead\134'.&quot;)); </Font><Font style="Text">
         </Font>end:<Font style="Text">

         </Font>for j from 1 to nops(algebraic_states) do
              if ( (has(tmp[1],algebraic_states[j][1])) ) then error(cat(&quot;post processing at index &quot;,convert(i,string),&quot; contains algebraic states. <Font encoding="UTF-8">Use \134'differential_post_processing instead\134'.</Font>&quot;) ): end:
        end:
        for j from 1 to nops(algebraic_controls) do
              if ((has(tmp[1],algebraic_controls[j][1])) ) then error(cat(&quot;post processing at index &quot;,convert(i,string),&quot; contains algebraic controls. <Font encoding="UTF-8">Use \134'differential_post_processing instead\134'.</Font>&quot;) ): end:
        end:<Font style="Text">

     </Font>end:<Font style="Text">
     end check post processing
</Font>
      _setPhase( phase, 
                 states,
                 controls,
                 algebraic_states,
                 algebraic_controls,
                   parameters,
                   lagrange_target,
                   mayer_target,
                   first_order_equations,
                   point_constraints,
                   integral_constraints,
                   path_constraints,
                   boundary_conditions,
                   event_constraints,
                   post_processing,
                   differential_post_processing,
                   integral_post_processing,
                   guess):

      writeline(default, &quot;Phase successfully created&quot;):
      writeline(default, cat(&quot;states: &quot;, convert([seq(op(0,states[i][1]),i=1..nops(states))],string))):
      writeline(default, cat(&quot;controls: &quot;, convert([seq(op(0,controls[i][1]),i=1..nops(controls))],string))):
      writeline(default, cat(&quot;algebraic states: &quot;, convert([seq(op(0,algebraic_states[i][1]),i=1..nops(algebraic_states))],string))):
      writeline(default, cat(&quot;algebraic controls: &quot;, convert([seq(op(0,algebraic_controls[i][1]),i=1..nops(algebraic_controls))],string))):
      writeline(default, cat(&quot;parameters: &quot;, convert([seq( parameters[i][1],i=1..nops(parameters))],string))):
      writeline(default, cat(&quot;number of point constraints: &quot;, convert(nops(point_constraints),string))):
      writeline(default, cat(&quot;number of path constraints: &quot;, convert(nops(path_constraints),string))):
      writeline(default, cat(&quot;number of integral constraints: &quot;, convert(nops(integral_constraints),string))):
      writeline(default, cat(&quot;number of boundary conditions: &quot;, convert(nops(boundary_conditions),string))):
      writeline(default, cat(&quot;number of event constraints: &quot;, convert(nops(event_constraints),string))):
      writeline(default, cat(&quot;number of post processing: &quot;, convert(nops(post_processing),string))):
      writeline(default, cat(&quot;number of differential post processing: &quot;, convert(nops(differential_post_processing),string))):
      writeline(default, cat(&quot;number of integral post processing: &quot;, convert(nops(integral_post_processing),string))):
      writeline(default, cat(&quot;number of guess: &quot;, convert(nops(guess),string))):
      
end: <Font style="Text">end proc setPhase
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MapFunctionToCustomObject := proc( functions::list([function = function]), object_name::string, class_name::string, {instance_name::string:=&quot;&quot;, namespace::string:=&quot;&quot;}) _mapFunctionToCustomObject(functions, object_name, class_name, instance_name, namespace): end:
_mapFunctionToCustomObject := proc( functions::list([function = function]), object_name::string, class_name::string, instance_name::string:=&quot;&quot;, namespace::string:=&quot;&quot;)
    local tmp, _instance_name, mess:

    check_has_init(true):

    if has([indices(__mapped_objects,'nolist')],object_name) then WARNING(&quot;Object already declared, it will be overwritten&quot;): end:
    if (instance_name=&quot;&quot;) then
      _instance_name := cat(&quot;_p_&quot;, object_name);
    else
       _instance_name := instance_name:
    end:
    __mapped_objects[object_name][&quot;functions&quot;] := functions:
    __mapped_objects[object_name][&quot;instance_name&quot;] := _instance_name:
    __mapped_objects[object_name][&quot;class_name&quot;] := class_name:
    __mapped_objects[object_name][&quot;namespace&quot;] := namespace:
    __mapped_objects[object_name][&quot;include&quot;] := cat(class_name, &quot;.hh&quot;);

    mess := &quot;Mapped functions&quot;:
    for tmp in functions do
        mess := cat( mess, &quot; &quot;, convert(op(0,lhs(tmp)),string), &quot; to &quot;, convert(op(0,rhs(tmp)),string), &quot;,&quot; ):
    end:
    mess := cat( mess, &quot; for object &quot;, object_name, &quot; of type &quot;, class_name):
    writeline(default,mess);
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">MapFunctionToMaverickObject := proc( functions::{list(function = function), function = function}, object_name::string, class_name::string, {instance_name::string:=&quot;&quot;} ) _mapFunctionToMaverickObject(functions, object_name, class_name, instance_name): end:
_mapFunctionToMaverickObject := proc( functions::{list(function = function), function = function}, object_name::string, class_name::string, {instance_name::string:=&quot;&quot;} )
    local tmp, _instance_name, mess:

    check_has_init(true):

    if has([indices(__mapped_maverick_objects,'nolist')],object_name) then WARNING(&quot;Object already declared, it will be overwritten&quot;): end:
    if (instance_name=&quot;&quot;) then
      _instance_name := cat(&quot;_p_&quot;, object_name);
    else
       _instance_name := instance_name:
    end:
    __mapped_maverick_objects[object_name][&quot;functions&quot;] := functions:
    __mapped_maverick_objects[object_name][&quot;instance_name&quot;] := _instance_name:
    __mapped_maverick_objects[object_name][&quot;class_name&quot;] := class_name:
    __mapped_maverick_objects[object_name][&quot;namespace&quot;] := &quot;MaverickUtils&quot;:
    __mapped_maverick_objects[object_name][&quot;include&quot;] := &quot;MaverickUtils/GenericFunction/GenericFunction1AInterface.hh&quot;:

    mess := &quot;Mapped functions&quot;:
    for tmp in functions do
        mess := cat( mess, &quot; &quot;, convert(op(0,lhs(tmp)),string), &quot; to &quot;, convert(op(0,rhs(tmp)),string), &quot;,&quot; ):
    end:
    mess := cat( mess, &quot; for object &quot;, object_name, &quot; of type &quot;, class_name):
    writeline(default,mess);
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">GenerateCode := proc( problem_name::string, { model_parameters::list(symbol):=[], output_directory::string := &quot;&quot; } )
    _generateCode(problem_name, model_parameters, output_directory):
end:
_generateCode := proc( problem_name::string, model_parameters::list(symbol):=[], output_directory::string := &quot;&quot; )
     local i;

     check_has_init(true):

     if ( nops(model_parameters) = 0 ) then WARNING(&quot;No model parameters have been specified&quot;): end:

     for i from 1 to __num_phases do
          if (__phase_declared[i]=false) then error(cat(&quot;Problem phase &quot;, convert(i,string), &quot; has not been specified&quot;)): end:
     end:

     writeline(default, &quot;Processing parameters...&quot;);
     Maverick:-setupParameters(model_parameters):

     writeline(default, &quot;Converting variables...&quot;);
     Maverick:-createConversion():

     MaverickCodegen:-generateOcpCode(problem_name, output_directory ):

     writeline(default, &quot;CODE GENERATION COMPLETE&quot;);
end:
</Text-field><Text-field style="Text" layout="Normal">@=============================================================@</Text-field><Text-field style="Text" layout="Normal">#  _       _                        _                         #</Text-field><Text-field style="Text" layout="Normal"># (_)_ __ | |_ ___ _ __ _ __   __ _| |  _ __  _ __ ___   ___  #</Text-field><Text-field style="Text" layout="Normal"><Font encoding="UTF-8"># | | '_ \134| __/ _ \134 '__| '_ \134 / _` | | | '_ \134| '__/ _ \134 / __| #</Font></Text-field><Text-field style="Text" layout="Normal"># | | | | | ||  __/ |  | | | | (_| | | | |_) | | | (_) | (__  #</Text-field><Text-field style="Text" layout="Normal"><Font encoding="UTF-8"># |_|_| |_|\134__\134___|_|  |_| |_|\134__,_|_| | .__/|_|  \134___/ \134___| #</Font></Text-field><Text-field style="Text" layout="Normal">#                                      |_|                    #</Text-field><Text-field style="Text" layout="Normal">@=============================================================@</Text-field><Text-field style="Text" layout="Normal"></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">Initialization procedure</Font>
init := proc(printheader::boolean:=false)
    __num_phases = 0; <Font style="Text">number of phases of the ocp problem</Font>
    __tabs := &quot;    &quot;:
    clear():
    MaverickCodegen:-initCode():
end: <Font style="Text">end init procedure
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">clear := proc()
    __OCP := '__OCP':
    __NLP := '__NLP':
    __model_params:=[]:      
    __mapped_maverick_objects:='__mapped_maverick_objects':  __mapped_maverick_objects[&quot;__mav&quot;]:=0:
    __mapped_objects:='__mapped_objects':   __mapped_objects[&quot;__mav&quot;]:=0:

    __phase_declared:=[]:

    MaverickCodegen:-clearCode():
end: <Font style="Text">clear proc
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">initialize the data list to empty list for all the phases</Font>
prepareForPhases := proc()
    local i;
    for i from 1 to __num_phases do
       __phase_declared:=[op(__phase_declared), false]:
    end:
end: <Font style="Text">prepare for phases procedure
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">check_has_init := proc(throw_error :: boolean)
local returned_value:
     if (__has_init = 1199) then
        returned_value := true;
     else
        returned_value := false;
        if (throw_error) then
            error(&quot;You must initialize the problem first. Please call 'NewOcpProblem( number_of_phases )' &quot;):
        end:
     end:
     returned_value;
end: <Font style="Text">check has init proc
</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">containsOneArrayElem := proc(expr, arr::Array)
   local contains, tmp:
   for tmp in arr do
       if (has(expr, tmp)) then return true; end if;
   end:

   return false:

end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">containsExactlyOneArrayElem := proc(expr, arr::Array)
   local contains, tmp:
   for tmp in arr do
       if ( expr = tmp ) then return true; end if;
   end:

   return false:

end:</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">procedure to process the parameters and create the conversion from params to C-params</Font>
setupParameters := proc(model_params::list(symbol):=[])
local tmp, i_s:
    __model_params_names_str := &quot;&quot;:
    for i_s from 1 to nops(model_params) do
         __model_params_names_str := cat(<Font encoding="UTF-8">__model_params_names_str, &quot;\134&quot;&quot;, convert(</Font>model_params[i_s],string)<Font encoding="UTF-8">, &quot;\134&quot;&quot;</Font>):
         if ( i_s &lt; nops(model_params)) then __model_params_names_str := cat(__model_params_names_str, &quot;, &quot;): end if:
    end do:

    __model_params_index_defines := &quot;&quot;:
    __model_params_convert := []:

    for i_s from 1 to nops(model_params) do
       tmp := cat( MOD_PAR_INDEX_, model_params[i_s] ):
       __model_params_convert := [ op(__model_params_convert), model_params[i_s] = '_model_params'[tmp+1] ]:
       __model_params_index_defines := cat(__model_params_index_defines,  &quot;#define &quot;, convert(tmp, string), &quot; &quot;, <Font encoding="UTF-8">convert(i_s-1,string), &quot;\134n&quot;):
</Font>    end do:
   #writeline(default,cat(&quot;number of parameters &quot;, convert(nops(model_params),string)));
   __num_model_params := nops(model_params):
end:
</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font style="Text">create the conversion strings from ocp to nlp</Font>
createConversion := proc()
local P, _nx, _nu, _nxu, _nax, _nau, _naxu, _np, __ocp_to_nlp_conv1, __ocp_to_nlp_conv2, __ocp_to_nlp_at_bc_conv:

     for P from 1 to __num_phases do
         _nx := nops(__OCP[P][&quot;states&quot;]); _nu := nops(__OCP[P][&quot;controls&quot;]); _nxu := _nx + _nu;
         _nax := nops(__OCP[P][&quot;algebraic_states&quot;]); _nau := nops(__OCP[P][&quot;algebraic_controls&quot;]); _naxu := _nax + _nau;
         _np := nops(__OCP[P][&quot;params&quot;]);


         __NLP[P][&quot;vars&quot;] := [ seq( __states_controls[i], i=1.._nxu) ];
         __NLP[P][&quot;diff_vars&quot;] := [ seq( __state_control_derivatives[i], i=1.._nxu) ] ;
         __NLP[P][&quot;alg_vars&quot;] := [ seq( __algebraic_states_controls[i], i=1.._naxu) ];
         __NLP[P][&quot;params&quot;] := [ seq( __parameters[i], i=1.._np) ] ;
         __NLP[P][&quot;i_vars&quot;] := [ seq( __initial_state_control[i], i=1.._nxu) ] ;
         __NLP[P][&quot;f_vars&quot;] := [ seq( __final_state_control[i], i=1.._nxu) ] ;

         </Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">         __ocp_to_nlp_conv1[P]  := [seq( diff(__OCP[P][&quot;states&quot;][i],zeta) = __NLP[P][&quot;diff_vars&quot;][i], i=1.._nx),
                                       seq( diff(__OCP[P][&quot;controls&quot;][i],zeta) = __NLP[P][&quot;diff_vars&quot;][_nx+i], i=1.._nu)];</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">         __ocp_to_nlp_conv2[P]  := [seq( __OCP[P][&quot;states&quot;][i] = __NLP[P][&quot;vars&quot;][i], i=1.._nx),
                                       seq( __OCP[P][&quot;controls&quot;][i] = __NLP[P][&quot;vars&quot;][_nx+i], i=1.._nu),
                                    seq( __OCP[P][&quot;algebraic_states&quot;][i] = __NLP[P][&quot;alg_vars&quot;][i], i=1.._nax),
                                       seq( __OCP[P][&quot;algebraic_controls&quot;][i] = __NLP[P][&quot;alg_vars&quot;][_nax+i], i=1.._nau),
                                       seq( __OCP[P][&quot;params&quot;][i] = __NLP[P][&quot;params&quot;][i], i=1.._np),
                                       zeta = __zeta];</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">         __ocp_to_nlp_at_bc_conv[P]  := [seq( op(0,__OCP[P][&quot;states&quot;][i])(zeta_i) = __NLP[P][&quot;i_vars&quot;][i], i=1.._nx),
                                            seq( op(0,__OCP[P][&quot;states&quot;][i])(zeta_f) = __NLP[P][&quot;f_vars&quot;][i], i=1.._nx),
                                            seq( op(0,__OCP[P][&quot;controls&quot;][i])(zeta_i) = __NLP[P][&quot;i_vars&quot;][_nx+i], i=1.._nu),
                                            seq( op(0,__OCP[P][&quot;controls&quot;][i])(zeta_f) = __NLP[P][&quot;f_vars&quot;][_nx+i], i=1.._nu),
                                            seq( __OCP[P][&quot;params&quot;][i] = __NLP[P][&quot;params&quot;][i], i=1.._np),
                                            zeta_i = __zeta_i, zeta_f = __zeta_f];</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">

     end do:

    MaverickCodegen:-setConversion(__ocp_to_nlp_conv1, __ocp_to_nlp_conv2, __ocp_to_nlp_at_bc_conv):

end: <Font style="Text">createConversion procedure</Font>

</Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">_setPhase := proc( phase::integer, 
                   states::list([algebraic,algebraic..algebraic]), 
                   controls::list([algebraic,algebraic..algebraic]),
                   algebraic_states::list([algebraic,algebraic..algebraic]), 
                   algebraic_controls::list([algebraic,algebraic..algebraic]), 
                   parameters::list([symbol,algebraic..algebraic]), 
                   lagrange_target::algebraic, 
                   mayer_target::algebraic,
                   first_order_equations::list, 
                   point_constraints::list([algebraic,algebraic..algebraic,string]), 
                   integral_constraints::list([algebraic,algebraic..algebraic,string]), 
                   path_constraints::list([algebraic,algebraic..algebraic,string]),
                   boundary_conditions::list([algebraic,algebraic..algebraic,string]),
                   event_constraints::list([algebraic,algebraic..algebraic,string]),
                   post_processing::list([algebraic,string]),
                   differential_post_processing::list([algebraic,string]),
                   integral_post_processing::list([algebraic,string]),
                   guess::list(equation)
                 )

    local tmp, tmp_vars, tmp_vars_nab, P, i, j, nnz;
      P := phase:

      tmp_vars := []: tmp_vars_nab := []:
      for tmp in states do
          tmp_vars := [ op(tmp_vars), tmp[1]]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(op(0,tmp[1]),string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;states&quot;] := tmp_vars: __OCP[P][&quot;states_nab&quot;] := tmp_vars_nab:

      tmp_vars := []: tmp_vars_nab := []:
      for tmp in controls do
          tmp_vars := [ op(tmp_vars), tmp[1]]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(op(0,tmp[1]),string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;controls&quot;] := tmp_vars: __OCP[P][&quot;controls_nab&quot;] := tmp_vars_nab:

      tmp_vars := []: tmp_vars_nab := []:
      for tmp in algebraic_states do
          tmp_vars := [ op(tmp_vars), tmp[1]]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(op(0,tmp[1]),string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;algebraic_states&quot;] := tmp_vars: __OCP[P][&quot;algebraic_states_nab&quot;] := tmp_vars_nab:

      tmp_vars := []: tmp_vars_nab := []:
      for tmp in algebraic_controls do
          tmp_vars := [ op(tmp_vars), tmp[1]]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(op(0,tmp[1]),string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;algebraic_controls&quot;] := tmp_vars: __OCP[P][&quot;algebraic_controls_nab&quot;] := tmp_vars_nab:

      tmp_vars := []: tmp_vars_nab := []:
      for tmp in parameters do
          tmp_vars := [ op(tmp_vars), tmp[1]]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[1],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;params&quot;] := tmp_vars: __OCP[P][&quot;params_nab&quot;] := tmp_vars_nab:

      nnz := nops(first_order_equations):
      tmp_vars := Array(1..nnz):
      for i from 1 to nnz do 
          tmp_vars[i] := first_order_equations[i]:
          if (type(tmp_vars[i],equation)) then
              tmp_vars[i] := lhs(tmp_vars[i]) - rhs(tmp_vars[i]):
          end:
      end do:
      __OCP[P][&quot;fo_eqns&quot;] := convert(tmp_vars,list):

      __OCP[P][&quot;lagrange_target&quot;] := lagrange_target:
      __OCP[P][&quot;mayer_target&quot;] := mayer_target:

      nnz := nops(point_constraints):
      tmp_vars := Array(1..nnz):
      tmp_vars_nab := []:
      for i from 1 to nnz do
          tmp := point_constraints[i]:
          tmp_vars[i] := tmp[1]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[3],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;point_constraints&quot;] := convert(tmp_vars,list):
      __OCP[P][&quot;point_constraints_nab&quot;] := tmp_vars_nab:

      nnz := nops(integral_constraints):
      tmp_vars := Array(1..nnz):
      tmp_vars_nab := []:
      for i from 1 to nnz do
          tmp := integral_constraints[i]:
          tmp_vars[i] := tmp[1]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[3],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;integral_constraints&quot;] := convert(tmp_vars,list):
      __OCP[P][&quot;integral_constraints_nab&quot;] := tmp_vars_nab:

      nnz := nops(path_constraints):
      tmp_vars := Array(1..nnz):
      tmp_vars_nab := []:
      for i from 1 to nnz do
          tmp := path_constraints[i]:
          tmp_vars[i] := tmp[1]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[3],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;diff_constraints&quot;] := convert(tmp_vars,list):
      __OCP[P][&quot;diff_constraints_nab&quot;] := tmp_vars_nab:

      nnz := nops(boundary_conditions):
      tmp_vars := Array(1..nnz):
      tmp_vars_nab := []:
      for i from 1 to nnz do
          tmp := boundary_conditions[i]:
          tmp_vars[i] := tmp[1]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[3],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;boundary_conditions&quot;] := convert(tmp_vars,list):
      __OCP[P][&quot;boundary_conditions_nab&quot;] := tmp_vars_nab:

      nnz := nops(event_constraints):
      tmp_vars := Array(1..nnz):
      tmp_vars_nab := []:
      for i from 1 to nnz do
          tmp := event_constraints[i]:
          tmp_vars[i] := tmp[1]:
          tmp_vars_nab := [ op(tmp_vars_nab), [ convert(tmp[3],string), op(1,tmp[2]), op(2,tmp[2]) ] ]:
      end do:
      __OCP[P][&quot;event_constraints&quot;] := convert(tmp_vars,list):
      __OCP[P][&quot;event_constraints_nab&quot;] := tmp_vars_nab:

      __OCP[P][&quot;post_processing&quot;] := post_processing:
      __OCP[P][&quot;differential_post_processing&quot;] := differential_post_processing:
      __OCP[P][&quot;integral_post_processing&quot;] := integral_post_processing:
      __OCP[P][&quot;guess&quot;] := guess:
      __phase_declared[P] := true:


end:</Text-field>
</Input>
<Input><Text-field prompt="&gt; " style="Maple Input" spaceabove="0" linebreak="space" rightmargin="0" linespacing="0.0" initial="0" firstindent="0" leftmargin="0" bulletsuffix="" alignment="left" bullet="none" spacebelow="0" pagebreak-before="false">end: <Font style="Text">end of maverick main module</Font></Text-field><Text-field prompt="&gt; " style="Maple Input" layout="Normal">savelib( 'Maverick' );</Text-field>
</Input>
</Group>
<Group labelreference="L586" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Section>
</Worksheet>